<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XMUTer的技术小站</title>
  <icon>https://www.gravatar.com/avatar/94a1c030063ab693dfd557261341ef5e</icon>
  
  <link href="https://xmuter.github.io/atom.xml" rel="self"/>
  
  <link href="https://xmuter.github.io/"/>
  <updated>2024-03-19T15:16:17.400Z</updated>
  <id>https://xmuter.github.io/</id>
  
  <author>
    <name>XMUTer Ye</name>
    <email>704388761@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快乐树</title>
    <link href="https://xmuter.github.io/2024/03/19/%E5%BF%AB%E4%B9%90%E6%A0%91/"/>
    <id>https://xmuter.github.io/2024/03/19/%E5%BF%AB%E4%B9%90%E6%A0%91/</id>
    <published>2024-03-19T14:58:27.000Z</published>
    <updated>2024-03-19T15:16:17.400Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>快乐树，你真的快乐吗？</p></blockquote><h1 id="第202题-快乐数"><a href="#第202题-快乐数" class="headerlink" title="第202题. 快乐数"></a>第202题. 快乐数</h1><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题看上去是数学题？错了。看完题目，注意题目说了，会<strong>无限循环</strong>。</p><p>一说到无限循环找交点，首先应该想到快慢指针，就像链表一样，有圆定能相遇。</p><p>做法1：</p><p>​因此做法一的思路就很明确了，定义快慢指针，让快指针每次做两次运算，慢指针做一次运算，他们一定会在某处相遇。相遇的地点为1的话，就是快乐树了。因为做的运算的相同的，因此可以把这个运算封装成一个函数进行调用。<strong>做法1见如下C语言代码</strong>。</p><p>做法2：</p><p>​因为题目说了会无限循环，因此想到，在某一时刻，会出现与之前相同的数。这个数出现的位置并不让人关心。因此，可以用c++的unordered_set容器来存储当前的值。利用迭代器对容器中存储的元素进行查找，若容器中没有发现该元素，则存入。直到发现当前值等于1，或者容器中有相同元素时停止。<strong>做法2见如下C++代码。</strong></p><p>本题还有一个重要的知识点，就是一个数n：</p><p>​取n%10后，就得到了个位的数值。</p><p>​取n&#x2F;10后，就是把个位去掉后的数组（舍去最低位，n整体向右移动一位）。</p><p>c语言实现如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        sum = sum + (n%<span class="number">10</span>)*(n%<span class="number">10</span>);</span><br><span class="line">        n = n/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fast = get(n);</span><br><span class="line">    <span class="type">int</span> slow = fast;</span><br><span class="line">    fast = get(fast);</span><br><span class="line">    <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">        fast = get(fast);</span><br><span class="line">        fast = get(fast);</span><br><span class="line">        slow = get(slow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fast==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用c++做的时候，在力扣上运行的话，需要单独定义一个get函数，单独对变量值进行处理，否则程序会运行超时。</p><p>c++实现如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;<span class="comment">//循环取得最后一位</span></span><br><span class="line">            sum = sum+ (n%<span class="number">10</span>)*(n%<span class="number">10</span>);</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> sum =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            sum = <span class="built_in">get</span>(n);            </span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">find</span>(sum) != hash.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                hash.<span class="built_in">insert</span>(sum); </span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;快乐树，你真的快乐吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;第202题-快乐数&quot;&gt;&lt;a href=&quot;#第202题-快乐数&quot; class=&quot;headerlink&quot; title=&quot;第202题. 快乐数&quot;&gt;&lt;/a&gt;第202题. 快乐数&lt;/</summary>
      
    
    
    
    <category term="算法刷题" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="数组" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="C++" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="C" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="hash" scheme="https://xmuter.github.io/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>两个数组的交集</title>
    <link href="https://xmuter.github.io/2024/03/18/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <id>https://xmuter.github.io/2024/03/18/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</id>
    <published>2024-03-18T13:14:06.000Z</published>
    <updated>2024-03-18T13:25:19.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349. 两个数组的交集 - 力扣（LeetCode）</a></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br><span class="line">解释：[4,9] 也是可通过的</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li></ul><p><strong>说明：</strong> 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题目，主要要学会使用一种哈希数据结构：unordered_set，这个数据结构可以解决很多类似的问题。</p><p>第二种解法使用c语言实现，见下文。</p><p><strong>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</strong>如果没有限制数值的大小，就无法使用数组来做哈希表了。<strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong>此时就要使用另一种结构体set。</p><p>关于set，C++ 给提供了如下三种可用的数据结构：</p><ul><li>std::set</li><li>std::multiset</li><li>std::unordered_set</li></ul><p>std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p><p>在C++11，使用for循环遍历数组中的元素时可以这样：</p><p><code>for（int num ： nums）</code>&#x2F;&#x2F;其中，nums是数组名字。</p><p>unordered_set容器和vector容器一样，可以使用insert（）插入元素，begin（），end（）迭代器跳转到容器开头或者结尾，还可以用find（）查找容器中存储的值。</p><p>c++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; ans; <span class="comment">//给结果去重用</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">num_set</span><span class="params">(nums1.begin(),nums1.end())</span></span>;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num :nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num_set.<span class="built_in">find</span>(num) != num_set.<span class="built_in">end</span>())&#123;</span><br><span class="line">                ans.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为c语言没有unordered_set容器可供使用，且题目所给的数据有一个范围，虽然范围较大，用数组做的话浪费内存。</p><p>思路是，先构建一个hash数组，对hash数组中的num1[i]的位置写值，然后再 遍历num2数组，查找对应位置的hash数组有没有存值，有的话则说明元素重复。</p><p>c语言代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">intersection</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> nums1Size, <span class="type">int</span>* nums2, <span class="type">int</span> nums2Size, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> min = nums1Size &gt; nums2Size ? nums2Size:nums1Size;</span><br><span class="line">   <span class="comment">// int max = nums1Size &gt; nums2Size ? nums1Size:nums2Size;</span></span><br><span class="line">    <span class="type">int</span> max =<span class="number">1005</span>;</span><br><span class="line">    <span class="type">int</span> hash[max]; </span><br><span class="line">    <span class="type">int</span>* ans = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*min);</span><br><span class="line">    <span class="built_in">memset</span>(hash,<span class="number">-1</span>,<span class="keyword">sizeof</span>(hash));</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums1Size;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( hash[nums1[i]] == <span class="number">-1</span>)&#123;</span><br><span class="line">            hash[nums1[i]] = nums1[i];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums2Size;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash[nums2[i]] == nums2[i])&#123;</span><br><span class="line">            ans[j] = nums2[i];</span><br><span class="line">            hash[nums2[i]] = <span class="number">-1</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = j;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;349-两个数组的交集&quot;&gt;&lt;a href=&quot;#349-两个数组的交集&quot; class=&quot;headerlink&quot; title=&quot;349. 两个数组的交集&quot;&gt;&lt;/a&gt;349. 两个数组的交集&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/pro</summary>
      
    
    
    
    <category term="算法刷题" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="数组" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="C++" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="C" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="hash" scheme="https://xmuter.github.io/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>Linux应用开发基础知识</title>
    <link href="https://xmuter.github.io/2024/03/17/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://xmuter.github.io/2024/03/17/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2024-03-17T15:02:01.000Z</published>
    <updated>2024-03-19T14:52:09.027Z</updated>
    
    <content type="html"><![CDATA[<p>main函数中的两个参数：</p><p>​argc argv 参数个数存储数组</p><p>​主要是传递参数用。</p><p>gcc 是c语言的编译工具</p><p>使用Linux-arm-gcc 编译完arm可执行程序后重新后，Ubuntu通过nfs网络文件系统传输文件至开发板，进行编译调试。</p><h3 id="挂载指令：（数据传输）"><a href="#挂载指令：（数据传输）" class="headerlink" title="挂载指令：（数据传输）"></a>挂载指令：（数据传输）</h3><p><code>mount -t nfs -o nolock,vers=3 192.168.3.40:/home/alienteek/linux/nfs get/ </code></p><p>-t nfs ： 网络文件系统</p><p>-o nolock 不带锁的，ver&#x3D;3（nfs版本是3.0） 地址是xxx.xxx.xxx.xxx：Ubuntu的nfs目录开发板存储目录</p><p>上面的指令意思是，把服务器上nfs里的文件挂载到开发板get文件夹里。</p><p>0若文件夹不存在，则要创建文件夹，使用<code>mkdir get</code></p><p>.h 申明-&gt;在系统目录中（工具链目录），或者自己指定</p><p>.c实现</p><p>用户态 user</p><p>内核态kernel</p><p>硬件</p><p>GCC编译器</p><p>预处理编译汇编链接 </p><p>程序错误是在编译时检查，预处理不检查</p><p>gcc -o  </p><p>gcc -c -o xxx.o 预处理编译汇编做了，但是不link</p><p>-I 指定目录找头文件 &lt; &gt;</p><p>静态库 ar crs xxx.a xxx.o</p><p>-L dir</p><p>-l动态库 链接</p><p>-E -dM &gt; .txt 展开所有宏，看宏的链接</p><p>arm-linux-gcc</p><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>目标文件 ： 依赖文件TAB+命令</p><p>当依赖比目标新，执行命令</p><p>gcc -c -o xxx.o xxx.c</p><p>gcc -o xxxa.o b.o</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>% 通配符号</p><p>gcc -c -o xxx.o xxx.cgcc -c -o<code> $@</code>$&lt;</p><p>gcc -o xxxa.o b.ogcc -o xxx$^</p><p>$@表示目标</p><p>$&lt;表示第一个依赖文件</p><p>$^表示所有依赖文件</p><p>假想目标： PHONY：文件夹下有同名文件的时候，不要执行。</p><p>即时变量（简单变量）、延时变量，expor</p><p>a :&#x3D;即时变量，马上确定的量，马上赋值</p><p>b &#x3D; 使用到的时候才赋值延时变量</p><p>？&#x3D;如果是第一次定义才起效，如果前面定义过该变量，则忽略这句话</p><p>+&#x3D;附加，它是及时变量还是延时变量，取决于前面的定义</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><code>$（foreach val，$(A),$(val).o）</code>遍历循环函数</p><p><code>filter</code>查找函数</p><p><code>fileter_out</code>查找取反</p><p>wildcard查找同一目录下的所有同后缀名的文件、查找真实存在的文件，从文件列表中</p><p>patsubst替换操作</p><p>gcc生成依赖</p><p>gcc -M打印出依赖 </p><p>-MF 依赖写入文件</p><p>ifneq</p><p>endif</p><p>CFLAGS 编译参数</p><p>1    - werror很多警告都是有错误的，要变成error </p><h4 id="通用Makefile"><a href="#通用Makefile" class="headerlink" title="通用Makefile"></a>通用Makefile</h4><p><a href="https://www.cnblogs.com/fortunely/p/16631713.html#%E9%80%9A%E7%94%A8makefile%E6%BA%90%E7%A0%81">Makefile笔记 韦东山通用Makefile解析 - 明明1109 - 博客园 (cnblogs.com)</a></p><h3 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h3><p>函数</p><p>标准IOf开头先把数据读入&#x2F;写入用户buffer，然后对其进行读写，一定条件后再执行系统调用IO</p><p>系统调用IOopen&#x2F;read&#x2F;write每次都会进入内核</p><p>posix 通用接口</p><p>open函数</p><p>man man 查找函数调用方法</p><p>O_RDWR 可读可写可操作</p><p>#include&lt;errno.h&gt;</p><p>perror(“open ”) 打印错误信息</p><p>fd -l</p><p>kill - 9 程序id</p><p>ls -l</p><p>cd &#x2F;proc&#x2F;id号&#x2F;fd</p><p>查看打开的文件</p><p>0 标准输入</p><p>1标准输出</p><p>2 标准错误</p><p>open 函数创建文件已存在的文件无法改变权限</p><p>O_CREAT 如果不存在，创建文件</p><p>man 2 open 查看手册</p><p>umask&#x2F;&#x2F;屏蔽参数，chmod&amp;~umask 得到文件权限。防止给文件夹过大的权限。例如，禁止给orhers写权限</p><p>写入数据</p><p>write </p><p>某个位置写</p><p>lseek文件读写偏移  </p><p>read函数</p><p>O_TRUNC</p><p>hexdump -C 文件名   打印文件，以126进制打印</p><p>\n \r 空格、换行 </p><p>strcpy  copy字符串的</p><p>sscanf：从字符串中得到数据</p><p>strlen（） 字符串大小</p><p>文件头部编码格式回车换行 0d 0a\r\n</p><p>系统调用接口，由glib.c实现。系统调用接口触发异常（设置原因）分辨异常（原因）处理异常（调用不同的函数）继续执行</p><p>glib.c、app.c 用户空间，用户层面</p><p>内核文件怎么打开？</p><p>接口：ABI</p><p>​  EABI</p><p>​  OABI</p><p>&#x2F;proc&#x2F;id 进入进程目录</p><p>程序句柄如何和具体文件挂钩？</p><p>内核：task_struct-&gt;files_struct-&gt;fdtable.file_rcu *fd，这个fd就是进程的fd号（程序句柄）</p><p><strong>每个进程有自己的文件句柄空间。</strong></p><p>不同的进程结构体file中的f_pos也不一样，虽然打开了相同文件</p><p>如果用dup（fd）（内核中会得到一个未使用的最小的文件句柄），让不同的文件句柄指向同一个fd，这样就 共用f_pos</p><p>输出句柄重定向 dup2（3，1）&#x2F;&#x2F;3号的复制到1号关闭1号文件，然后1号指针指向3号</p><p>dup3</p><h3 id="Framebuffer应用编程"><a href="#Framebuffer应用编程" class="headerlink" title="Framebuffer应用编程"></a>Framebuffer应用编程</h3><p>LCD一种驱动程序</p><p>用来保存一帧数据的内存</p><p>要知道分辨率、bpp：每个像素用多少位来表示</p><p>offset：偏移地址，比如（x，y）的像素：<code> （y*x方向的像素分辨率 + x）*bpp/8</code>  第一行是0，0开始的</p><p>RGB888（32BPP）</p><p>16BPP RGB565 RGB555</p><p>获取lcd 参数 根据偏移地址找到相应左边</p><p>open：打开驱动程序</p><p>ioctl ：获取lcd参数</p><p>mmap：映射frambuffer</p><p>描点函数fb_base</p><p>RGB颜色转换：</p><p>例如888-&gt;565:最高的不取取高5位置高6位 高5位置就行、</p><p>888： 24bit16bit8bit0bit最高8位是AAAAAAAA</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;main函数中的两个参数：&lt;/p&gt;
&lt;p&gt;​		argc 	argv 	参数个数	存储数组&lt;/p&gt;
&lt;p&gt;​		主要是传递参数用。&lt;/p&gt;
&lt;p&gt;gcc 是c语言的编译工具&lt;/p&gt;
&lt;p&gt;使用Linux-arm-gcc 编译完arm可执行程序后重新后，Ubuntu通过nfs</summary>
      
    
    
    
    <category term="嵌入式Linux基础" scheme="https://xmuter.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>有效的字母异位词</title>
    <link href="https://xmuter.github.io/2024/03/17/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <id>https://xmuter.github.io/2024/03/17/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</id>
    <published>2024-03-17T03:26:10.000Z</published>
    <updated>2024-03-17T03:34:35.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h1><p><a href="https://leetcode.cn/problems/valid-anagram/description/">242. 有效的字母异位词 - 力扣（LeetCode）</a></p><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s &#x3D; “anagram”, t &#x3D; “nagaram” 输出: true</p><p>示例 2: 输入: s &#x3D; “rat”, t &#x3D; “car” 输出: false</p><p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>错误思路：本题不可以对两个字符串中的字符asc码分别相加，判断是否相等来做。因为字符串中的字符不相等，asc码相加的结果也可能是相同的。</p><p>正确思路：构建hash表，构建hash function，一个字符串写入数据，另一个字符串删除数据，判断hash表中的元素是否为0。（前提是hash初始化，存储的所有元素都为0）</p><p>本题所需要构造的hash表较小，且数据范围也小，因此使用数组来构建hash表。</p><p>c语言代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isAnagram</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i ;</span><br><span class="line">    <span class="type">int</span> hash[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">memset</span>(hash,<span class="number">0</span>,<span class="keyword">sizeof</span>(hash));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);i++)&#123;</span><br><span class="line">        hash[ s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(t);i++)&#123;</span><br><span class="line">        hash[ t[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i= <span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash[i] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span></span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            record[t[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;242-有效的字母异位词&quot;&gt;&lt;a href=&quot;#242-有效的字母异位词&quot; class=&quot;headerlink&quot; title=&quot;242.有效的字母异位词&quot;&gt;&lt;/a&gt;242.有效的字母异位词&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/p</summary>
      
    
    
    
    <category term="算法刷题" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="数组" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="C++" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="C" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="hash" scheme="https://xmuter.github.io/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>hash表学习</title>
    <link href="https://xmuter.github.io/2024/03/17/hash%E8%A1%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://xmuter.github.io/2024/03/17/hash%E8%A1%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-03-17T01:26:02.000Z</published>
    <updated>2024-03-17T03:28:06.643Z</updated>
    
    <content type="html"><![CDATA[<p>hash实现快速插入和快速查找（时间复杂度都为O（1））</p><p>对于data构造一个函数，得到data的hash值，存入hash表中。  </p><p>和函数一样，一个输入都有对应的输出。</p><h2 id="hash扩容"><a href="#hash扩容" class="headerlink" title="hash扩容"></a>hash扩容</h2><p>负载因子 &#x3D; 实际存放元素&#x2F;数组容量</p><p>式子右边大于负载因子时候需要扩容，把所有元素重新插入到新的hash表中</p><h2 id="hash碰撞（多个输入对应同一个输出）"><a href="#hash碰撞（多个输入对应同一个输出）" class="headerlink" title="hash碰撞（多个输入对应同一个输出）"></a>hash碰撞（多个输入对应同一个输出）</h2><p>使用二次hash</p><ul><li>线性探测法</li></ul><p>增：在数组中查找空位，存放数据。</p><p>查：查找的时候，若在原本的值的位置没有，就往下遍历查找，一直查找到空为止。</p><p>删：要把对于位置赋值为-1（相当于伪删除）。如果不给值的话，在查找的时候就找不到删除元素之后的元素。</p><ul><li>开放探测法</li><li>随机探测法</li><li>使用链表</li></ul><p>数组、值小，范围可控</p><p>set、数组很大</p><p>map、k对应有value</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hash实现快速插入和快速查找（时间复杂度都为O（1））&lt;/p&gt;
&lt;p&gt;对于data构造一个函数，得到data的hash值，存入hash表中。  &lt;/p&gt;
&lt;p&gt;和函数一样，一个输入都有对应的输出。&lt;/p&gt;
&lt;h2 id=&quot;hash扩容&quot;&gt;&lt;a href=&quot;#hash扩容&quot;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://xmuter.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="hash" scheme="https://xmuter.github.io/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>环形链表Ⅱ</title>
    <link href="https://xmuter.github.io/2024/03/16/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1/"/>
    <id>https://xmuter.github.io/2024/03/16/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1/</id>
    <published>2024-03-16T06:50:39.000Z</published>
    <updated>2024-03-16T07:02:42.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II - 力扣（LeetCode）</a></p><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3><p>​可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</p><p>​fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇，而不是永远的错开。因为fast是一个节点一个节点的追赶slow的，因此不会错开的。</p><p>​因此，fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇。</p><h3 id="如果有环，如何找到这个环的入口"><a href="#如果有环，如何找到这个环的入口" class="headerlink" title="如果有环，如何找到这个环的入口"></a>如果有环，如何找到这个环的入口</h3><p>相遇时： slow指针走过的节点数为: <code>x + y</code>， fast指针走过的节点数：<code>x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。</p><p>因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 &#x3D; slow指针走过的节点数 * 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x + y) * 2 = x + y + n (y + z)</span><br></pre></td></tr></table></figure><p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p><p>因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。</p><p>所以要求x ，将x单独放在左面：<code>x = n (y + z) - y</code> ,</p><p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code> 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p><p>而相遇时候，快指针走了几圈这并不让我关心，我关心的是环形的入口处在哪。假设<code>n=1</code>时候，此时<code>x=z</code>，就是说，当两个指针相遇的时候，再走x步就到环的入口点了。这个x是什么呢？这个x是从链表头走到环形入口的距离。</p><p>就是说，<code>(n - 1) (y + z)</code>其实就说fast指针多转的圈数，也是让我不关心的。</p><p>c语言实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">detectCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* low = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;<span class="comment">//fast一次走两步</span></span><br><span class="line">        low = low-&gt;next;<span class="comment">//low一次走一步</span></span><br><span class="line">        <span class="keyword">if</span>(fast == low)&#123;<span class="comment">//两个环相遇</span></span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span>(fast != low)&#123;<span class="comment">//到入环口出退出</span></span><br><span class="line">                fast = fast-&gt;next;<span class="comment">//此时fast从头开始走，一次走一步</span></span><br><span class="line">                low = low-&gt;next;<span class="comment">//从相遇点往前走。一次走一步</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;142-环形链表II&quot;&gt;&lt;a href=&quot;#142-环形链表II&quot; class=&quot;headerlink&quot; title=&quot;142.环形链表II&quot;&gt;&lt;/a&gt;142.环形链表II&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/</summary>
      
    
    
    
    <category term="算法刷题" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="链表" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="C++" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="C" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="双指针法" scheme="https://xmuter.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>链表相交</title>
    <link href="https://xmuter.github.io/2024/03/16/%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/"/>
    <id>https://xmuter.github.io/2024/03/16/%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/</id>
    <published>2024-03-16T06:34:43.000Z</published>
    <updated>2024-03-16T06:51:04.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交 - 力扣（LeetCode）</a></p><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><blockquote><p>ps：链表相交并不是说两个链表中的元素相等而已，而是指链表交点的指针（就是说两个链表中，存在某一元素存储的地址是一致的），并且从这个地址之后的所有元素都相等。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>暴力解法：（c语言实现）</p><p>​个人第一次解的时候使用的方法，使用两个循环，查找地址相同的两个节点，并且指向的下一个地址也相同，则就是两个链表的交点。</p><p>巧妙解法：（C++实现）</p><ul><li>得出两个链表长度</li><li>计算链表长度差gap（C++中可以用swap（a，b），快速交换a和b的值）</li><li>长链表指针先移动gap位，使得两个链表尾部对齐</li><li>开始同时遍历长链表和短链表，找到相同的地址节点后返回</li></ul><p>这么做的话也就是说，两个链表要是相交的话，一定从短链表中的元素开始的。</p><p>c语言代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">getIntersectionNode</span><span class="params">(<span class="keyword">struct</span> ListNode *headA, <span class="keyword">struct</span> ListNode *headB)</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">    ListNode* B = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    B-&gt;next = headB;</span><br><span class="line">    ListNode* cur = B;</span><br><span class="line">    ListNode* ans = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(headA)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">if</span>((cur-&gt;next == headA-&gt;next) &amp;&amp; (cur == headA))&#123;<span class="comment">//是接下来的指向的位置相等，不是存储的数字相等</span></span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        headA = headA-&gt;next;</span><br><span class="line">        cur = B;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lenB = <span class="number">0</span>;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">while</span>(curB != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="keyword">if</span>(lenB&gt;lenA)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(lenA,lenB);<span class="comment">//快速交换两个元素的值</span></span><br><span class="line">            <span class="built_in">swap</span>(curA,curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> gap = lenA - lenB;</span><br><span class="line">        <span class="keyword">while</span>(gap)&#123;</span><br><span class="line">            gap--;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curA==curB)&#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA=curA-&gt;next;</span><br><span class="line">            curB=curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面试题-02-07-链表相交&quot;&gt;&lt;a href=&quot;#面试题-02-07-链表相交&quot; class=&quot;headerlink&quot; title=&quot;面试题 02.07. 链表相交&quot;&gt;&lt;/a&gt;面试题 02.07. 链表相交&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://lee</summary>
      
    
    
    
    <category term="算法刷题" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="链表" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="C++" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="C" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="双指针法" scheme="https://xmuter.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>删除链表的倒数第N个节点</title>
    <link href="https://xmuter.github.io/2024/03/15/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>https://xmuter.github.io/2024/03/15/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
    <published>2024-03-15T13:14:43.000Z</published>
    <updated>2024-03-15T13:26:36.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h1><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/submissions/512403868/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题思路有二：</p><p>第一种：</p><p>自己的做法。</p><ul><li>使用虚拟头节点对链表进行反转操作</li><li>用cnt从前遍历n个，然后删除该节点</li><li>再次使用虚拟头节点对链表进行反转</li></ul><p>第二种：</p><p>双指针、虚拟头节点法做。</p><p>为什么要用虚拟头节点的方法做？</p><p>因为用虚拟头节点做的话可以不用考虑删除的元素是否为头节点。虚拟头节点一直指向的是链表的头节点的位置，就算链表的头结点变了，虚拟头节点还是可以link到新的头节点的位置。</p><ul><li>使用一个快指针前进n+1个节点</li><li>快、慢指针同时向前走，直到快指针遍历结束</li><li>此时慢指针指向n-1元素的位置，直接删除第n个元素即可</li></ul><p>以下c语言的做法就是用的第一种方法做的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">    ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    ListNode* temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">cout</span> =<span class="number">1</span>;</span><br><span class="line">    ListNode* phead = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    phead-&gt;next = pre;</span><br><span class="line">    cur = phead;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cout</span> == n)&#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>++;</span><br><span class="line">        cur = cur-&gt;next;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    cur = phead-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下c++代码实现第二种方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* phead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        phead-&gt;next = head;</span><br><span class="line">        ListNode* fast = phead;</span><br><span class="line">        ListNode* low = phead;</span><br><span class="line">        <span class="keyword">while</span>(n-- &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            low = low-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* temp = low-&gt;next;</span><br><span class="line">        low-&gt;next = low-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;19-删除链表的倒数第N个节点&quot;&gt;&lt;a href=&quot;#19-删除链表的倒数第N个节点&quot; class=&quot;headerlink&quot; title=&quot;19.删除链表的倒数第N个节点&quot;&gt;&lt;/a&gt;19.删除链表的倒数第N个节点&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://l</summary>
      
    
    
    
    <category term="算法刷题" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="链表" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="C++" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="C" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="虚拟头节点" scheme="https://xmuter.github.io/tags/%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9/"/>
    
    <category term="双指针法" scheme="https://xmuter.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>两两交换链表中的节点</title>
    <link href="https://xmuter.github.io/2024/03/14/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://xmuter.github.io/2024/03/14/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</id>
    <published>2024-03-14T14:41:46.000Z</published>
    <updated>2024-03-14T15:01:28.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h1><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<img src="../%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/1.png" alt="1"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题目正常模拟就可以了。</p><p>建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。</p><p>做题时候记得先画图，按照图中指针指向的链路写代码就行。使用虚拟头节点的话，这个过程简单很多。注意一下，在交换完一次节点后，需要把虚拟头节点向后移动！一定要移动！</p><p>以下是c++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">ListNode* pre = <span class="keyword">new</span> ListNode;</span><br><span class="line"><span class="keyword">if</span> (pre == <span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line">pre-&gt;next = head;</span><br><span class="line">ListNode* cur = pre;</span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)&#123;</span><br><span class="line">ListNode* first = cur-&gt;next;</span><br><span class="line">ListNode* third = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line">cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">cur-&gt;next-&gt;next = first;</span><br><span class="line">cur-&gt;next-&gt;next-&gt;next = third;</span><br><span class="line">cur = cur-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">head = pre-&gt;next;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>c语言实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">swapPairs</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">ListNode* pre = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line"><span class="keyword">if</span> (pre == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line">pre-&gt;next = head;</span><br><span class="line">ListNode* cur = pre;</span><br><span class="line"><span class="keyword">while</span> ((cur-&gt;next)&amp;&amp; cur-&gt;next-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* temp1 = cur-&gt;next;<span class="comment">//1</span></span><br><span class="line">ListNode* temp = cur-&gt;next-&gt;next-&gt;next;<span class="comment">//3</span></span><br><span class="line">cur-&gt;next = cur-&gt;next-&gt;next;<span class="comment">//cur point 2</span></span><br><span class="line">cur-&gt;next-&gt;next = temp1; <span class="comment">//2 point 1</span></span><br><span class="line">temp1-&gt;next = temp;<span class="comment">//1 point 3</span></span><br><span class="line">        cur = cur-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">head = pre-&gt;next;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;24-两两交换链表中的节点&quot;&gt;&lt;a href=&quot;#24-两两交换链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;24. 两两交换链表中的节点&quot;&gt;&lt;/a&gt;24. 两两交换链表中的节点&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcod</summary>
      
    
    
    
    <category term="数据结构" scheme="https://xmuter.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="C" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="链表" scheme="https://xmuter.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="模拟过程" scheme="https://xmuter.github.io/tags/%E6%A8%A1%E6%8B%9F%E8%BF%87%E7%A8%8B/"/>
    
    <category term="虚拟头节点" scheme="https://xmuter.github.io/tags/%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>设计链表</title>
    <link href="https://xmuter.github.io/2024/03/14/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
    <id>https://xmuter.github.io/2024/03/14/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</id>
    <published>2024-03-14T10:15:03.000Z</published>
    <updated>2024-03-14T10:31:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h1><p><a href="https://leetcode.cn/problems/design-linked-list/description/">力扣</a></p><p>题意：</p><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>链表的增删查改实现。与之前学的数据结构<a href="https://xmuter.github.io/2024/03/02/%E7%BA%BF%E6%80%A7%E8%A1%A8List%E5%AD%A6%E4%B9%A0/">链表学习</a>不太一样。当时写了链表的创建、删除，认为增加和修改操作大同小异，就没有实践。知道做了这一题，才发现了许多没注意的细节问题。</p><p>链表问题，可以用数组、双指针的思路来解决。</p><p>​数组算是暴力解，先把链表中的值存在数组中，然后按照 规定取出组成新链表。</p><p>​双指针的话则要注意pre、cur指针，一定要平移，元素的位置不能动。总之，元素和指针只能动一个，不可以两个同时动，否则会被卷入循环漩涡，出不来结果。</p><p>​做题时一定要画图，把思路写出来，再实现代码，会对代码实现的逻辑有比较清楚的把控，debug的时候容易找出问题所在处。</p><p>​做题的时候要注意，头节点是否变动！！！（运行完函数后，是否有返回头节点）</p><p>以下是C语言实现设计链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyLinkedList</span>&#123;</span></span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyLinkedList</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; MyLinkedList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyLinkedList* <span class="title function_">myLinkedListCreate</span><span class="params">()</span> &#123;<span class="comment">//链表创建</span></span><br><span class="line">MyLinkedList* L = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">L-&gt;val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myLinkedListGet</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> index)</span> &#123;<span class="comment">//获取下标为index的节点值，没有返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">cout</span> = <span class="number">0</span>;</span><br><span class="line">obj = obj-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (obj)&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="built_in">cout</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> obj-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line">obj = obj-&gt;next;</span><br><span class="line"><span class="built_in">cout</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListAddAtHead</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> val)</span> &#123;<span class="comment">//插入至第一个元素之前</span></span><br><span class="line">MyLinkedList* first = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">first-&gt;val = val;</span><br><span class="line">first-&gt;next = obj-&gt;next;</span><br><span class="line">obj-&gt;next= first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListAddAtTail</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> val)</span> &#123;<span class="comment">//插入至最后一个元素之后</span></span><br><span class="line">MyLinkedList* last = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">last-&gt;val = val;</span><br><span class="line">last-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">MyLinkedList* cur;</span><br><span class="line">cur = obj-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">obj-&gt;next = last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (cur)&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">cur-&gt;next = last;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListAddAtIndex</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;<span class="comment">//将val插入下标index节点之前</span></span><br><span class="line">MyLinkedList* mid = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));<span class="comment">//没注意。如果index等于链表长度，则把val加在链表末端</span></span><br><span class="line">MyLinkedList* before = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">MyLinkedList* cur;</span><br><span class="line">MyLinkedList* pre = obj;</span><br><span class="line">mid-&gt;val = val;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="built_in">cout</span> = <span class="number">0</span>;</span><br><span class="line">cur = obj-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur)&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="built_in">cout</span>)</span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;next= mid;</span><br><span class="line">mid-&gt;next = cur;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>++;<span class="comment">//在cur指向NULL的时候，cout还加了1</span></span><br><span class="line">pre = cur;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == (<span class="built_in">cout</span>)&amp;&amp;flag)&#123;</span><br><span class="line">pre-&gt;next = mid;</span><br><span class="line">mid-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListDeleteAtIndex</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> index)</span> &#123;<span class="comment">//如果下标有效，删除下标为index的节点</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">cout</span> = <span class="number">0</span>;</span><br><span class="line">MyLinkedList* pre = obj;</span><br><span class="line">MyLinkedList* temp;</span><br><span class="line">MyLinkedList* cur;</span><br><span class="line"><span class="comment">//temp = obj-&gt;next;//第一个元素</span></span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>)&#123;</span><br><span class="line">temp = obj-&gt;next;</span><br><span class="line">obj-&gt;next = obj-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">cur = obj-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (index !=<span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="built_in">cout</span>)</span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;next = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>++;</span><br><span class="line">pre = cur;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListFree</span><span class="params">(MyLinkedList* obj)</span> &#123;<span class="comment">//释放链表所有元素</span></span><br><span class="line">MyLinkedList* cur;</span><br><span class="line">MyLinkedList* pre;</span><br><span class="line">cur = obj-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur)&#123;</span><br><span class="line">pre = cur;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(pre);</span><br><span class="line">&#125;</span><br><span class="line">pre = obj;</span><br><span class="line"><span class="built_in">free</span>(pre);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;707-设计链表&quot;&gt;&lt;a href=&quot;#707-设计链表&quot; class=&quot;headerlink&quot; title=&quot;707.设计链表&quot;&gt;&lt;/a&gt;707.设计链表&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/design-l</summary>
      
    
    
    
    <category term="数据结构" scheme="https://xmuter.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="C" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="链表" scheme="https://xmuter.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>翻转链表</title>
    <link href="https://xmuter.github.io/2024/03/13/%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://xmuter.github.io/2024/03/13/%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2024-03-13T14:09:11.000Z</published>
    <updated>2024-03-13T14:15:01.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣</a></p><p>题意：反转一个单链表。</p><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用双指针法做。注意使用双指针法的时候，不要改变元素的位置，可以添加额外的指针来凑双指针。若改变元素位置来做，容易陷入死循环，导致做错。</p><p>C语言代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span>   </span><br><span class="line"><span class="comment">/* pre  cur   cur-&gt;next */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pre</span> =</span><span class="literal">NULL</span>;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur =temp;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;206-反转链表&quot;&gt;&lt;a href=&quot;#206-反转链表&quot; class=&quot;headerlink&quot; title=&quot;206.反转链表&quot;&gt;&lt;/a&gt;206.反转链表&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/reverse-</summary>
      
    
    
    
    <category term="算法刷题" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="链表" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="C++" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="C" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="双指针法" scheme="https://xmuter.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>移除链表元素</title>
    <link href="https://xmuter.github.io/2024/03/12/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <id>https://xmuter.github.io/2024/03/12/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</id>
    <published>2024-03-12T14:06:54.000Z</published>
    <updated>2024-03-14T14:18:14.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h1><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素 - 力扣（LeetCode）</a></p><p>题意：删除链表中等于给定值 val 的所有节点。</p><p>示例 1： 输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6 输出：[1,2,3,4,5]</p><p>示例 2： 输入：head &#x3D; [], val &#x3D; 1 输出：[]</p><p>示例 3： 输入：head &#x3D; [7,7,7,7], val &#x3D; 7 输出：[]</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>随想录中使用两种方法移除链表元素。直接删除的方法如下。</p><p>2023.3.14补充：后续补充虚拟头节点的做法。假设一个虚拟头节点，指向head，通过虚拟头节点的不断移动来寻找相同的元素。此过程head没有变化。</p><p>做的过程中，直接删除的方法的难点在于：</p><ul><li>如何返回头节点。</li><li>如何把元素从上一个节点链接到下一个节点。</li></ul><p>C语言实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一 判断链表头结点是否为目标值，不是的话去掉</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">ListNode* after = <span class="literal">NULL</span>;</span><br><span class="line">ListNode* cur;<span class="comment">//构造一个参数，等于head</span></span><br><span class="line"><span class="keyword">while</span> (head &amp;&amp; head-&gt;val == val)&#123;<span class="comment">//判断头节点是否有val值，有的话去掉</span></span><br><span class="line">ListNode* temp = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">cur = head;<span class="comment">//一定是没有head值</span></span><br><span class="line"><span class="keyword">while</span> (cur)&#123;<span class="comment">//对cur进行操作，若为NULL，则说明已经遍历完节点</span></span><br><span class="line">after = cur-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (after &amp;&amp; after-&gt;val == val)&#123;<span class="comment">//要判断after是否存在</span></span><br><span class="line">cur-&gt;next = after-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(after);<span class="comment">//删除节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">ListNode* cur;</span><br><span class="line">ListNode* after;</span><br><span class="line">ListNode* temp;</span><br><span class="line"><span class="keyword">while</span> (head &amp;&amp; head-&gt;val == val)&#123;</span><br><span class="line">temp = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">cur = head;</span><br><span class="line"><span class="keyword">while</span> (cur)&#123;</span><br><span class="line">after = cur-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (after &amp;&amp; after-&gt;val == val)&#123;</span><br><span class="line">cur-&gt;next = after-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> after;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用虚拟头节点。。注意，使用虚拟头节点存储的头指针，在后续的指针操作中，若改变了链表中的头节点，虚拟头节点是始终指向链表的头结点的。</p><p>例如，虚拟头节点的next &#x3D; head；</p><p>​head由于临时指针（自己定义的一个指针，这个指针等于虚拟头节点，他们指向同一个位置）增删改变了，此时的next自动指向修改过后的head。</p><p>C语言实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">ListNode* pre = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="literal">NULL</span>)&#123;<span class="comment">//判断pre是否为空，若为空则直接返回报错。</span></span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line">pre-&gt;next = head;<span class="comment">// point to head</span></span><br><span class="line">ListNode* cur = pre;</span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next)&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">ListNode* temp = cur-&gt;next;</span><br><span class="line">cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">head = pre-&gt;next;<span class="comment">// delete old head ,pre will point new head auto.</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;203-移除链表元素&quot;&gt;&lt;a href=&quot;#203-移除链表元素&quot; class=&quot;headerlink&quot; title=&quot;203.移除链表元素&quot;&gt;&lt;/a&gt;203.移除链表元素&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/</summary>
      
    
    
    
    <category term="算法刷题" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="链表" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="C++" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="C" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="虚拟头节点" scheme="https://xmuter.github.io/tags/%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>C语言学习笔记</title>
    <link href="https://xmuter.github.io/2024/03/11/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://xmuter.github.io/2024/03/11/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-11T15:40:12.000Z</published>
    <updated>2024-03-11T15:52:10.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h1><p>C语言中malloc是动态内存分配函数，C++中使用new关键字<br>函数原型：void *malloc(unsigned int num_bytes);</p><p>​void *malloc(sizeof（） * n);  </p><p>表示从堆山动态获取[sizeof（）*n] 大小的空间,</p><p> 其中，void*是泛指的指针类型。可以转换为任意指针类型的参数，一般与sizeof中的类型一致。例如：</p><p>​int* p &#x3D; （int*） malloc(sizeof（int） * n);  </p><p>参数：num_bytes 是无符号整型，用于表示分配的字节数。<br>返回值：如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。void 表示未确定类型的指针，void *可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据。<br>功能：分配长度为num_bytes字节的内存块<br>注意：当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。关于该函数的原型，在以前malloc返回的是char型指针，新的ANSIC标准规定，该函数返回为void型指针，因此必要时要进行类型转换。</p><h1 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;malloc函数&quot;&gt;&lt;a href=&quot;#malloc函数&quot; class=&quot;headerlink&quot; title=&quot;malloc函数&quot;&gt;&lt;/a&gt;malloc函数&lt;/h1&gt;&lt;p&gt;C语言中malloc是动态内存分配函数，C++中使用new关键字&lt;br&gt;函数原型：void </summary>
      
    
    
    
    <category term="语言学习" scheme="https://xmuter.github.io/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C" scheme="https://xmuter.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>螺旋矩阵</title>
    <link href="https://xmuter.github.io/2024/03/11/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <id>https://xmuter.github.io/2024/03/11/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</id>
    <published>2024-03-11T13:23:20.000Z</published>
    <updated>2024-03-14T15:05:17.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h1><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/submissions/510572866/">59. 螺旋矩阵 II - 力扣（LeetCode）</a></p><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><p>二维数组的构造，以及模拟过程的逻辑掌控。</p><p>C语言构建数组较为麻烦，C++则可以利用容器来构造数组。</p><p>还需要多复习多用C语言如何使用指针构造二维数组。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题目可以说在面试中出现频率较高的题目，<strong>本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。</strong></p><p>本题依然是要坚持循环不变量原则。</p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。</p><p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是<strong>一进循环深似海，从此offer是路人</strong>。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>关于二位数组的指针表示，以下为个人拙见：</p><p>​首先，数组使用指针表示的时候，其实是存储数组首位的地址。因为数组的存储地址是连续的。若是一维数组，则直接使用int<em>，存储数组首位地址就行。int</em>* 可表示二位数组，int*<em>指向 int</em>，int再指向存储的int。<br>​初始化时，先用<code>int** n = （int**）malloc（sizeof（int）n）；</code>先创建存储二维数组的n行空间；再用for循环，对 <code>*（n+i）= （int*）malloc（sizeof（int）*n）；</code>创建二位数组的n列空间。其中，*（n+i）表示从n向右移动的位数。</p><p>整体C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 使用vector定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 定义每循环一个圈的起始位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>; <span class="comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line">        <span class="type">int</span> mid = n / <span class="number">2</span>; <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span> (loop --) &#123;</span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">            <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; n - offset; j++) &#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; n - offset; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">            offset += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O(n^2): 模拟遍历二维矩阵的时间</li><li>空间复杂度 O(1)</li></ul><p>c代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>** <span class="title function_">generateMatrix</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>* returnSize, <span class="type">int</span>* *returnColumnSizes)</span> &#123;</span><br><span class="line">*returnSize = n;</span><br><span class="line">*returnColumnSizes = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line"><span class="type">int</span>** ans = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * n);</span><br><span class="line"><span class="type">int</span> i; <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">ans[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">(*returnColumnSizes)[i] = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = n / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> loop = n / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> startx = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> starty = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> end = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (loop)&#123;</span><br><span class="line"><span class="keyword">for</span> ( j = starty; j &lt; n - end; j++)&#123;</span><br><span class="line">ans[startx][j] = num;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ( i = startx; i &lt; n - end; i++)&#123;</span><br><span class="line">ans[i][j] = num;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ( j = n - end; j &gt; starty; j--)&#123;</span><br><span class="line">ans[i][j] = num;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = n - end; i &gt; startx; i--) &#123;</span><br><span class="line">ans[i][j] = num;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">startx++;</span><br><span class="line">starty++;</span><br><span class="line">end++;</span><br><span class="line">loop--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">ans[mid][mid] = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;59-螺旋矩阵II&quot;&gt;&lt;a href=&quot;#59-螺旋矩阵II&quot; class=&quot;headerlink&quot; title=&quot;59.螺旋矩阵II&quot;&gt;&lt;/a&gt;59.螺旋矩阵II&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/spir</summary>
      
    
    
    
    <category term="算法刷题" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="数组" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="C++" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="C" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="模拟过程" scheme="https://xmuter.github.io/tags/%E6%A8%A1%E6%8B%9F%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>有序数组的平方</title>
    <link href="https://xmuter.github.io/2024/03/10/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
    <id>https://xmuter.github.io/2024/03/10/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</id>
    <published>2024-03-10T06:08:13.000Z</published>
    <updated>2024-03-10T07:19:13.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h1><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">力扣链接</a></p><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1：</p><ul><li>输入：nums &#x3D; [-4,-1,0,3,10]</li><li>输出：[0,1,9,16,100]</li><li>解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</li></ul><p>示例 2：</p><ul><li>输入：nums &#x3D; [-7,-3,2,3,11]</li><li>输出：[4,9,9,49,121]</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="暴力排序"><a href="#暴力排序" class="headerlink" title="暴力排序"></a>暴力排序</h3><p>最直观的想法，莫过于：每个数平方之后，排个序。本人于2024年3月9号尝试用c语言写过，奈何忘了排序算法该怎么写。以下C++代码抄自网上，有时间需要<strong>复习常见排序算法</strong>。C++实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            A[i] *= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>()); <span class="comment">// 快速排序</span></span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个时间复杂度是 O(n + nlogn)， 可以说是O(nlogn)的时间复杂度，但为了和下面双指针法算法时间复杂度有鲜明对比，我记为 O(n + nlog n)。</p><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><p>第一次尝试时遇到的问题：</p><p>​第一次看完双指针法的理论后去实践，从数组两边往中间逼近的方法进行排序，for循环里的条件是<code>for（int i；i&gt;=j；i--）</code>，i是数组最右边，j是数组最左边，然后比较它们，谁大谁幅值给ans[i]。这样做在运行时发现了许多问题，就是当 j&gt;i ，存完ans值后，直接i–。这意味着直接丢弃了nums[i]的值，是不对的。</p><p>C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size() ,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> index = nums.<span class="built_in">size</span>() <span class="number">-1</span>; index &gt;=<span class="number">0</span>; index --)&#123;</span><br><span class="line"><span class="type">int</span> rsquare = nums[right] * nums[right];</span><br><span class="line"><span class="type">int</span> lsquare = nums[left] * nums[left];</span><br><span class="line"><span class="keyword">if</span> (rsquare &gt;=lsquare)&#123;</span><br><span class="line">ans[index] = rsquare;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (lsquare &gt;rsquare)&#123;</span><br><span class="line">ans[index] = lsquare;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的时间复杂度为O(n)。</p><p>C语言实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">sortedSquares</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">*returnSize = numsSize;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = numsSize <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span>* ans = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * numsSize);</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> index =numsSize <span class="number">-1</span>; index &gt;= <span class="number">0</span>; index -- ) &#123;</span><br><span class="line"><span class="type">int</span> lsquare = nums[left] * nums[left];</span><br><span class="line"><span class="type">int</span> rsquare = nums[right] * nums[right];</span><br><span class="line"><span class="keyword">if</span> (rsquare &gt;= lsquare) &#123;</span><br><span class="line">ans[index] = rsquare;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rsquare &lt; lsquare) &#123;</span><br><span class="line">ans[index] = lsquare;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双指针法思路借鉴于<a href="https://www.programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;977-有序数组的平方&quot;&gt;&lt;a href=&quot;#977-有序数组的平方&quot; class=&quot;headerlink&quot; title=&quot;977.有序数组的平方&quot;&gt;&lt;/a&gt;977.有序数组的平方&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/probl</summary>
      
    
    
    
    <category term="算法刷题" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="数组" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="C++" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="C" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="双指针法" scheme="https://xmuter.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>长度最小的子数组</title>
    <link href="https://xmuter.github.io/2024/03/10/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>https://xmuter.github.io/2024/03/10/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2024-03-10T05:47:28.000Z</published>
    <updated>2024-03-10T07:20:36.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h1><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/submissions/509918082/">力扣链接</a></p><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><ul><li>输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</li><li>输出：2</li><li>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; target &lt;&#x3D; 10^9</li><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</li><li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>​使用两个for循环，然后不断的寻找符合条件的子序列，时间复杂度是O(n^2)。暴力解法在2024年3月10日没有试过。代码如下（copy至其他网友）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MAX; <span class="comment">// 最终的结果</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 子序列的数值之和</span></span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>; <span class="comment">// 子序列的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 设置子序列起点为i</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 设置子序列终止位置为j</span></span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s) &#123; <span class="comment">// 一旦发现子序列和超过了s，更新result</span></span><br><span class="line">                    subLength = j - i + <span class="number">1</span>; <span class="comment">// 取子序列的长度</span></span><br><span class="line">                    result = result &lt; subLength ? result : subLength;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>​滑动窗口就是使用两个指针（两个变量），其中一个指向靠后的数据，一个指向靠前的数据。靠前的指针一直向靠后的指针移动，直到条件满足为止。滑动窗口在数组中查找连续的数时使用较为灵活。</p><p>​所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环完成了一个不断搜索区间的过程。</p><p>那么滑动窗口如何用一个for循环来完成这个操作呢？</p><p>​首先要思考如果用一个for循环，那么应该表示滑动窗口的起始位置，还是终止位置。如果只用一个for循环来表示滑动窗口的起始位置，那么如何遍历剩下的终止位置？此时难免再次陷入暴力解法的怪圈。所以只用一个for循环，那么这个循环的索引，一定是表示滑动窗口的终止位置。</p><p>在本题中实现滑动窗口，主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p>窗口就是满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</p><p>解题的关键在于 窗口的起始位置如何移动，如图所示：</p><p><img src="../%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/2.png" alt="2"></p><p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。</strong></p><p>C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> min = INT32_MAX;<span class="comment">//取int32的最大值</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>; <span class="comment">//窗口起始点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">sum = sum + nums[i];</span><br><span class="line"><span class="keyword">while</span> (sum &gt;= target)&#123;</span><br><span class="line"><span class="type">int</span> minlength = i - j + <span class="number">1</span>;</span><br><span class="line">min = min &lt; minlength ? min : minlength;</span><br><span class="line">sum = sum - nums[j];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result = min == INT32_MAX ? <span class="number">0</span> : min;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>C代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line"><span class="type">int</span> min = INT32_MAX;</span><br><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">sum = nums[i] +sum;</span><br><span class="line"><span class="keyword">while</span> (sum &gt;=target)&#123;</span><br><span class="line"><span class="type">int</span> numlength = i - j + <span class="number">1</span>;</span><br><span class="line">min = numlength &lt; min ? numlength : min;</span><br><span class="line">sum = sum - nums[j];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result = (min == INT32_MAX) ? <span class="number">0</span> : min;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上对于滑动窗口的学习参考<a href="https://www.programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;209-长度最小的子数组&quot;&gt;&lt;a href=&quot;#209-长度最小的子数组&quot; class=&quot;headerlink&quot; title=&quot;209.长度最小的子数组&quot;&gt;&lt;/a&gt;209.长度最小的子数组&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/p</summary>
      
    
    
    
    <category term="算法刷题" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="数组" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="C++" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="C" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="滑动窗口" scheme="https://xmuter.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>移除元素</title>
    <link href="https://xmuter.github.io/2024/03/09/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>https://xmuter.github.io/2024/03/09/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</id>
    <published>2024-03-09T06:59:51.000Z</published>
    <updated>2024-03-10T11:29:03.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h1><p><a href="https://leetcode.cn/problems/remove-element/">力扣链接</a></p><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1: 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p><p>示例 2: 给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p><strong>你不需要考虑数组中超出新长度后面的元素。</strong></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</strong></p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>这个题目暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。</p><p>删除过程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (val == nums[i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; numsSize <span class="number">-1</span>; j++)&#123;</span><br><span class="line">nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">i--;<span class="comment">//元素向左移动一位，因此i要重新判断是否与目标值一样</span></span><br><span class="line">numsSize = numsSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numsSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p>定义快慢指针</p><ul><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组（for循环遍历）</li><li>慢指针：指向更新 新数组下标的位置（数组下标++）</li></ul><p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p><p>C语言实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= numsSize<span class="number">-1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (val != nums[i]) &#123;</span><br><span class="line">nums[x] = nums[i];</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这些实现方法并没有改变元素的相对位置！</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val != nums[fastIndex]) &#123;</span><br><span class="line">                nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>双指针法思路借鉴于<a href="https://www.programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;27-移除元素&quot;&gt;&lt;a href=&quot;#27-移除元素&quot; class=&quot;headerlink&quot; title=&quot;27. 移除元素&quot;&gt;&lt;/a&gt;27. 移除元素&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/remove-ele</summary>
      
    
    
    
    <category term="算法刷题" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="数组" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="C++" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="C" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="双指针法" scheme="https://xmuter.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://xmuter.github.io/2024/03/09/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://xmuter.github.io/2024/03/09/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2024-03-09T02:18:06.000Z</published>
    <updated>2024-03-15T13:16:49.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h1><p><a href="https://leetcode.cn/problems/binary-search/description/">力扣链接</a></p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9     </span><br><span class="line">输出: 4       </span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4     </span><br></pre></td></tr></table></figure><p>1<br>2<br>3</p><p>示例 2:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2     </span><br><span class="line">输出: -1        </span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1        </span><br></pre></td></tr></table></figure><p>1<br>2<br>3</p><p>提示：</p><ul><li>你可以假设 nums 中的所有元素是不重复的。</li><li>n 将在 [1, 10000]之间。</li><li>nums 的每个元素都将在 [-9999, 9999]之间。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>这道题目的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p><p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p><p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p><p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p><p>下面二分写法区间定义为左闭右闭即[left, right]。</p><p><strong>二分查找的左区间left，是可以返回x&lt;target&lt;y中，x+1的下标的！</strong></p><p>c语言实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"><span class="type">int</span> right = numsSize - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;<span class="comment">// 防止溢出 等同于(left + right)/2</span></span><br><span class="line"><span class="keyword">if</span> (target &lt; nums[mid])&#123;</span><br><span class="line">right = mid - <span class="number">1</span>; <span class="comment">//mid  肯定不是目标值，所以右边界减1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">left = mid +<span class="number">1</span>; <span class="comment">//mid  肯定不是目标值，所以左边界加1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;<span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 未找到目标值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(log n)</li><li>空间复杂度：O(1)</li></ul><p>C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (right &gt;= left) &#123;</span><br><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上学习参考<a href="https://www.programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;704-二分查找&quot;&gt;&lt;a href=&quot;#704-二分查找&quot; class=&quot;headerlink&quot; title=&quot;704. 二分查找&quot;&gt;&lt;/a&gt;704. 二分查找&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/binary</summary>
      
    
    
    
    <category term="算法刷题" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    <category term="数组" scheme="https://xmuter.github.io/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="C++" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="C" scheme="https://xmuter.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>imx6u开发学习笔记</title>
    <link href="https://xmuter.github.io/2024/03/06/imx6u%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://xmuter.github.io/2024/03/06/imx6u%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-06T08:21:26.000Z</published>
    <updated>2024-03-17T15:19:34.960Z</updated>
    
    <content type="html"><![CDATA[<p><strong>mfgtool 上位机固化系统</strong></p><p>直接点击Mfgtool2-eMMC-ddr512-eMMC.vbs即可在线固化</p><p><strong>应用层操控硬件的两种方式</strong></p><p>在 Linux 系统下，一切皆文件！应用层如何操控底层硬件，同样也是通过文件 I&#x2F;O 的方式来实现。设备文件便是各种硬件设备向应用层提供的一个接口，应用层通过对设备文件的 I&#x2F;O 操作</p><p>控硬件设备，譬如 LCD 显示屏、串口、按键、摄像头等等，所以设备文件其实是与硬件设备相互对应的。设备文件通常在&#x2F;dev&#x2F;目录下，我们也把&#x2F;dev 目录下的文件称为设备节点。</p><p>设备节点并不是操控硬件设备的唯一途径，除此之外，我们还可以通过 sysfs 文件系统对硬件设备进行操控。</p><p><strong>sysfs</strong> <strong>文件系统</strong></p><p>sysfs 是一个基于内存的文件系统，同 devfs、proc 文件系统一样，称为虚拟文件系统。它的</p><p>作用是将内核信息以文件的方式提供给应用层使用。</p><p>系统中所有的设备（对象）都会在&#x2F;sys&#x2F;devices 体现出来，是 sysfs 文件系统中最重要的目录结构；而&#x2F;sys&#x2F;bus、&#x2F;sys&#x2F;class、&#x2F;sys&#x2F;dev 分别将设备按照挂载的总线类型、功能分类以及设备号的形式将设备组织存放在这些目录中，这些目录下的文件都是链接到了&#x2F;sys&#x2F;devices 中。</p><p>这里给大家进行一个总结，应用层想要对底层硬件进行操控，通常可以通过两种方式：</p><ul><li><p>&#x2F;dev&#x2F;目录下的设备文件（设备节点）；</p></li><li><p>&#x2F;sys&#x2F;目录下设备的属性文件。</p></li></ul><p>通常情况下，一般简单地设备会</p><p>​使用 sysfs 方式操控，其设备驱动在实现时会将设备的一些属性导出到用户空间 sysfs 文件系统，以属性文件的形式为用户空间提供对这些数据、属性的访问支持，譬如 LED、GPIO 等。但对于一些较复杂的设备通常会使用设备节点的方式，譬如 LCD 等、触摸屏、摄像头等。</p><p><strong>标准接口与非标准接口</strong></p><p> mkdir get 创建get文件夹</p><p> mount -t nfs -o nolock,nfsvers&#x3D;3 192.168.3.40:&#x2F;home&#x2F;alienteek&#x2F;linux&#x2F;nfs get&#x2F;</p><p>umount get&#x2F;&#x2F;卸载get目录</p><p>可执行文件运行起始地址（运行时候的位置，固定的）存储地址是可以变的</p><p>学习路线</p><p>uboot不学</p><p>Linux内核 裁剪移植 不学</p><p>先学 Linux应用开发基础知识第四</p><p>在学驱动开发基础知识第五</p><p>项目实战</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;mfgtool 上位机固化系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接点击Mfgtool2-eMMC-ddr512-eMMC.vbs即可在线固化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用层操控硬件的两种方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Linux 系统下，一</summary>
      
    
    
    
    <category term="开源项目" scheme="https://xmuter.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>栈Stack学习</title>
    <link href="https://xmuter.github.io/2024/03/04/%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/"/>
    <id>https://xmuter.github.io/2024/03/04/%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-03-04T12:33:25.000Z</published>
    <updated>2024-03-07T15:15:56.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>​栈（Stack）是只允许在一端进行插入或删除的线性表。首先栈是一种线性表，但限定这种线性表<strong>只能在某一端进行插入和删除操作</strong>。</p><p><img src="../%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/1.png" alt="1"></p><p><strong>栈顶</strong>（Top）：线性表允许进行插入删除的那一端。<br><strong>栈底</strong>（Bottom）：固定的，不允许进行插入和删除的另一端。<br><strong>空栈</strong>：不含任何元素的空表。</p><p>栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构</p><h2 id="栈的常见基本操作"><a href="#栈的常见基本操作" class="headerlink" title="栈的常见基本操作"></a>栈的常见基本操作</h2><ul><li>InitStack(&amp;S)：初始化一个空栈S</li><li>StackEmpty(S)：判断一个栈是否为空，若栈为空则返回true，否则返回false</li><li>Push(&amp;S, x)：进栈（栈的插入操作），若栈S未满，则将x加入使之成为新栈顶</li><li>Pop(&amp;S, &amp;x)：出栈（栈的删除操作），若栈S非空，则弹出栈顶元素，并用x返回</li><li>GetTop(S, &amp;x)：读栈顶元素，若栈S非空，则用x返回栈顶元素</li><li>DestroyStack(&amp;S)：栈销毁，并释放S占用的存储空间（“&amp;”表示引用调用）</li></ul><h1 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h1><h2 id="栈的顺序存储"><a href="#栈的顺序存储" class="headerlink" title="栈的顺序存储"></a>栈的顺序存储</h2><p>​采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。<br>若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判断条件定位top等于-1。<br>​若现在有一个栈，StackSize是5，则栈的普通情况、空栈、满栈的情况分别如下图所示：</p><p><img src="../%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/2.1.png" alt="2.1"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>代码实现与顺序表的思路差不多。不过栈是后进先出。头文件如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;String&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> elemtype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">elemtype* elem;</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line">&#125;stack;</span><br></pre></td></tr></table></figure><p>实现的功能如下所示。进栈函数可改成动态的。若栈已满可扩容，思路与顺序表扩容一样。以下代码并未实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Initstack</span><span class="params">(stack&amp; S , <span class="type">int</span> size)</span></span>;<span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">stackempty</span><span class="params">(stack* S)</span></span>;<span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(stack* S, elemtype x)</span></span>;<span class="comment">//进栈，只能在顶层</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(stack* S, elemtype x)</span></span>;<span class="comment">//出栈,出顶层的</span></span><br><span class="line"><span class="function">elemtype <span class="title">gettop</span><span class="params">(stack* S)</span></span>;<span class="comment">//读取栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delstack</span><span class="params">(stack &amp;S)</span></span>;<span class="comment">//销毁栈，释放空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(stack* S)</span></span>;<span class="comment">//显示栈中元素</span></span><br></pre></td></tr></table></figure><p>函数具体细节如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Initstack</span><span class="params">(stack&amp; S, <span class="type">int</span> size)</span> </span>&#123;<span class="comment">//初始化栈</span></span><br><span class="line">S.elem = <span class="keyword">new</span> elemtype[size];</span><br><span class="line">S.size = size;</span><br><span class="line"><span class="keyword">if</span> (S.elem == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">S.top = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">stackempty</span><span class="params">(stack* S)</span> </span>&#123;<span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(stack* S, elemtype x)</span> </span>&#123;<span class="comment">//进栈，只能在顶层</span></span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == (S-&gt;size <span class="number">-1</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">S-&gt;top++;</span><br><span class="line">S-&gt;elem[S-&gt;top] = x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(stack* S, elemtype x)</span> </span>&#123;<span class="comment">//出栈,出顶层的</span></span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">x = S-&gt;elem[S-&gt;top];</span><br><span class="line">S-&gt;top--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">elemtype <span class="title">gettop</span><span class="params">(stack* S)</span> </span>&#123;<span class="comment">//读取栈顶元素</span></span><br><span class="line">elemtype x;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">x = S-&gt;elem[S-&gt;top];</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delstack</span><span class="params">(stack&amp; S)</span> </span>&#123;<span class="comment">//销毁栈，释放空间</span></span><br><span class="line">S.elem = <span class="literal">NULL</span>;</span><br><span class="line">S.top = <span class="number">-1</span>;</span><br><span class="line">S.size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">delete</span>[] S.elem;</span><br><span class="line"><span class="keyword">if</span> (S.elem == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(stack* S)</span> </span>&#123;<span class="comment">//显示栈中元素</span></span><br><span class="line"><span class="type">int</span> n = S-&gt;top;</span><br><span class="line"><span class="keyword">while</span> (n&gt;<span class="number">-1</span>)&#123;</span><br><span class="line">cout &lt;&lt; S-&gt;elem[n];</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试主代码如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">stack S;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Initstack</span>(S,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">stackempty</span>(&amp;S);</span><br><span class="line"> x = <span class="built_in">gettop</span>(&amp;S);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;top is : &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; input 4 num :&quot;</span> &lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="built_in">push</span>(&amp;S, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">display</span>(&amp;S);</span><br><span class="line"><span class="built_in">pop</span>(&amp;S,x);</span><br><span class="line"><span class="built_in">display</span>(&amp;S);</span><br><span class="line"><span class="type">bool</span> re = <span class="built_in">delstack</span>(S);</span><br><span class="line"><span class="keyword">if</span> (re == <span class="number">1</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;del success&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="../%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/3.png" alt="3"></p><h2 id="共享栈（两栈共享空间）"><a href="#共享栈（两栈共享空间）" class="headerlink" title="共享栈（两栈共享空间）"></a>共享栈（两栈共享空间）</h2><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​利用栈底位置相对不变的特征，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸，如下图所示：</p><p><img src="../%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/4.png" alt="4"></p><p>​两个栈的栈顶指针都指向栈顶元素，top0&#x3D;-1时0号栈为空，top1&#x3D;MaxSize时1号栈为空；仅当两个栈顶指针相邻（top0+1&#x3D;top1）时，判断为栈满。当0号栈进栈时top0先加1再赋值，1号栈进栈时top1先减一再赋值出栈时则刚好相反。</p><p>代码实现与顺序栈差不多。就是两个栈共享一段存储空间，元素入栈、出栈时需要判断对哪个栈进行操作。</p><h1 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h1><h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><p>​采用链式存储的栈称为链栈，链栈的优点是<strong>便于多个栈共享存储空间和提高其效率</strong>，且<strong>不存在栈满上溢</strong>的情况。通常采用单链表实现，并规定<strong>所有操作都是在单链表的表头进行</strong>。这里规定<strong>链栈没有头节点</strong>，<strong>Lhead指向栈顶元素</strong>，如下图所示。</p><p><img src="../%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/5.png" alt="5"></p><p>对于<strong>空栈</strong>来说，链表原定义是头指针指向空，那么链栈的空其实就是<strong>top&#x3D;NULL</strong>的时候。</p><h3 id="链栈进栈"><a href="#链栈进栈" class="headerlink" title="链栈进栈"></a>链栈进栈</h3><p>​对于链栈的进栈push操作，假设元素值为e的新节点是s，top为栈顶指针，示意图如下：</p><p><img src="../%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/6.1.png" alt="6.1"></p><h3 id="链栈的出栈"><a href="#链栈的出栈" class="headerlink" title="链栈的出栈"></a>链栈的出栈</h3><p>​链栈的出栈pop操作，也是很简单的三句操作。假设变量p用来存储要删除的栈顶结点，将栈顶指针下移以为，最后释放p即可，如下图所示：</p><p><img src="../%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/7.png" alt="7"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>​链栈的进栈相当于链表的前向插入，first in last out。以下代码思想主要是借鉴list链表的构建方法，使用head指针一直指向top。入栈时则head指向新的node，新的node的next指向之前的top。</p><p>头文件如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;String&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">Node* next;<span class="comment">//结构体指针</span></span><br><span class="line"><span class="type">int</span> cout;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><p>实现的函数如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initstack</span><span class="params">(Node *head)</span></span>;<span class="comment">//初始化栈</span></span><br><span class="line"><span class="function">Node* <span class="title">addnode</span><span class="params">(Node *head, <span class="type">int</span> data)</span></span>; <span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">display</span><span class="params">(Node* head, <span class="type">int</span> x)</span></span>;<span class="comment">//遍历打印链表,查找元素个数</span></span><br><span class="line"><span class="function">Node* <span class="title">findnode</span><span class="params">(Node* head, <span class="type">int</span> x)</span></span>;<span class="comment">//查找指针位置</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delnode</span><span class="params">(Node* head, <span class="type">int</span> n)</span></span>;<span class="comment">//出栈</span></span><br></pre></td></tr></table></figure><p>具体函数细节如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initstack</span><span class="params">(Node* head)</span> </span>&#123;<span class="comment">//初始化栈</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">head-&gt;cout = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">addnode</span><span class="params">(Node* head, <span class="type">int</span> data)</span> </span>&#123;<span class="comment">//入栈</span></span><br><span class="line">Node* s = <span class="keyword">new</span> Node; <span class="comment">// 分配结点新空间</span></span><br><span class="line">Node* tail = <span class="literal">NULL</span>;</span><br><span class="line">s-&gt;data = data;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;cout ==<span class="number">0</span>)&#123;</span><br><span class="line">head-&gt;next = s;</span><br><span class="line">s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">head-&gt;cout++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">s-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = s;</span><br><span class="line">head-&gt;cout++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">display</span><span class="params">(Node* head, <span class="type">int</span> x)</span> </span>&#123;<span class="comment">//遍历打印链表,查找元素个数</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">Node* p = head-&gt;next;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;链栈中的元素有：&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (p!= <span class="literal">NULL</span>) &#123;<span class="comment">//p本身就是指针变量</span></span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (x == p-&gt;data) &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">findnode</span><span class="params">(Node* head, <span class="type">int</span> x)</span> </span>&#123;<span class="comment">//查找指针位置</span></span><br><span class="line">Node* p = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (x == p-&gt;data) &#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delnode</span><span class="params">(Node* head, <span class="type">int</span> n)</span> </span>&#123;<span class="comment">//出栈</span></span><br><span class="line">Node* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p ==<span class="literal">NULL</span>)&#123;<span class="comment">//栈中没有元素</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">n = p-&gt;data;</span><br><span class="line">Node* after = p-&gt;next;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ssssss:   &quot;</span> &lt;&lt; after-&gt;data;</span><br><span class="line">head-&gt;next = after;</span><br><span class="line">head-&gt;cout--;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验截图如下所示</p><p><img src="../%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/8.png" alt="8"></p><p><a href="https://blog.csdn.net/Real_Fool_/article/details/113852222">数据结构：栈和队列(Stack &amp; Queue)【详解】-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;栈的定义&quot;&gt;&lt;a href=&quot;#栈的定义&quot; class=&quot;headerlink&quot; title=&quot;栈的定义&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="数据结构" scheme="https://xmuter.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="C++" scheme="https://xmuter.github.io/tags/C/"/>
    
    <category term="顺序栈" scheme="https://xmuter.github.io/tags/%E9%A1%BA%E5%BA%8F%E6%A0%88/"/>
    
    <category term="链栈" scheme="https://xmuter.github.io/tags/%E9%93%BE%E6%A0%88/"/>
    
  </entry>
  
</feed>
