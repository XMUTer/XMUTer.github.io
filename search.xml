<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux应用开发基础知识</title>
      <link href="/2024/03/17/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/03/17/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>main函数中的两个参数：</p><p>​argc argv 参数个数存储数组</p><p>​主要是传递参数用。</p><p>gcc 是c语言的编译工具</p><p>使用Linux-arm-gcc 编译完arm可执行程序后重新后，Ubuntu通过nfs网络文件系统传输文件至开发板，进行编译调试。</p><h3 id="挂载指令：（数据传输）"><a href="#挂载指令：（数据传输）" class="headerlink" title="挂载指令：（数据传输）"></a>挂载指令：（数据传输）</h3><p><code>mount -t nfs -o nolock,vers=3 192.168.3.40:/home/alienteek/linux/nfs get/ </code></p><p>-t nfs ： 网络文件系统</p><p>-o nolock 不带锁的，ver&#x3D;3（nfs版本是3.0） 地址是xxx.xxx.xxx.xxx：Ubuntu的nfs目录开发板存储目录</p><p>上面的指令意思是，把服务器上nfs里的文件挂载到开发板get文件夹里。</p><p>若文件夹不存在，则要创建文件夹，使用<code>mkdir get</code></p><p>.h 申明-&gt;在系统目录中（工具链目录），或者自己指定</p><p>.c实现</p><p>用户态 user</p><p>内核态kernel</p><p>硬件</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>有效的字母异位词</title>
      <link href="/2024/03/17/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
      <url>/2024/03/17/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h1><p><a href="https://leetcode.cn/problems/valid-anagram/description/">242. 有效的字母异位词 - 力扣（LeetCode）</a></p><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s &#x3D; “anagram”, t &#x3D; “nagaram” 输出: true</p><p>示例 2: 输入: s &#x3D; “rat”, t &#x3D; “car” 输出: false</p><p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>错误思路：本题不可以对两个字符串中的字符asc码分别相加，判断是否相等来做。因为字符串中的字符不相等，asc码相加的结果也可能是相同的。</p><p>正确思路：构建hash表，构建hash function，一个字符串写入数据，另一个字符串删除数据，判断hash表中的元素是否为0。（前提是hash初始化，存储的所有元素都为0）</p><p>本题所需要构造的hash表较小，且数据范围也小，因此使用数组来构建hash表。</p><p>c语言代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isAnagram</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i ;</span><br><span class="line">    <span class="type">int</span> hash[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">memset</span>(hash,<span class="number">0</span>,<span class="keyword">sizeof</span>(hash));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);i++)&#123;</span><br><span class="line">        hash[ s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(t);i++)&#123;</span><br><span class="line">        hash[ t[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i= <span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash[i] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span></span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            record[t[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hash表学习</title>
      <link href="/2024/03/17/hash%E8%A1%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/17/hash%E8%A1%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>hash实现快速插入和快速查找（时间复杂度都为O（1））</p><p>对于data构造一个函数，得到data的hash值，存入hash表中。  </p><p>和函数一样，一个输入都有对应的输出。</p><h2 id="hash扩容"><a href="#hash扩容" class="headerlink" title="hash扩容"></a>hash扩容</h2><p>负载因子 &#x3D; 实际存放元素&#x2F;数组容量</p><p>式子右边大于负载因子时候需要扩容，把所有元素重新插入到新的hash表中</p><h2 id="hash碰撞（多个输入对应同一个输出）"><a href="#hash碰撞（多个输入对应同一个输出）" class="headerlink" title="hash碰撞（多个输入对应同一个输出）"></a>hash碰撞（多个输入对应同一个输出）</h2><p>使用二次hash</p><ul><li>线性探测法</li></ul><p>增：在数组中查找空位，存放数据。</p><p>查：查找的时候，若在原本的值的位置没有，就往下遍历查找，一直查找到空为止。</p><p>删：要把对于位置赋值为-1（相当于伪删除）。如果不给值的话，在查找的时候就找不到删除元素之后的元素。</p><ul><li>开放探测法</li><li>随机探测法</li><li>使用链表</li></ul><p>数组、值小，范围可控</p><p>set、数组很大</p><p>map、k对应有value</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环形链表Ⅱ</title>
      <link href="/2024/03/16/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1/"/>
      <url>/2024/03/16/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II - 力扣（LeetCode）</a></p><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3><p>​可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</p><p>​fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇，而不是永远的错开。因为fast是一个节点一个节点的追赶slow的，因此不会错开的。</p><p>​因此，fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇。</p><h3 id="如果有环，如何找到这个环的入口"><a href="#如果有环，如何找到这个环的入口" class="headerlink" title="如果有环，如何找到这个环的入口"></a>如果有环，如何找到这个环的入口</h3><p>相遇时： slow指针走过的节点数为: <code>x + y</code>， fast指针走过的节点数：<code>x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。</p><p>因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 &#x3D; slow指针走过的节点数 * 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x + y) * 2 = x + y + n (y + z)</span><br></pre></td></tr></table></figure><p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p><p>因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。</p><p>所以要求x ，将x单独放在左面：<code>x = n (y + z) - y</code> ,</p><p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code> 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p><p>而相遇时候，快指针走了几圈这并不让我关心，我关心的是环形的入口处在哪。假设<code>n=1</code>时候，此时<code>x=z</code>，就是说，当两个指针相遇的时候，再走x步就到环的入口点了。这个x是什么呢？这个x是从链表头走到环形入口的距离。</p><p>就是说，<code>(n - 1) (y + z)</code>其实就说fast指针多转的圈数，也是让我不关心的。</p><p>c语言实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">detectCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* low = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;<span class="comment">//fast一次走两步</span></span><br><span class="line">        low = low-&gt;next;<span class="comment">//low一次走一步</span></span><br><span class="line">        <span class="keyword">if</span>(fast == low)&#123;<span class="comment">//两个环相遇</span></span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span>(fast != low)&#123;<span class="comment">//到入环口出退出</span></span><br><span class="line">                fast = fast-&gt;next;<span class="comment">//此时fast从头开始走，一次走一步</span></span><br><span class="line">                low = low-&gt;next;<span class="comment">//从相遇点往前走。一次走一步</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> 双指针法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表相交</title>
      <link href="/2024/03/16/%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/"/>
      <url>/2024/03/16/%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交 - 力扣（LeetCode）</a></p><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><blockquote><p>ps：链表相交并不是说两个链表中的元素相等而已，而是指链表交点的指针（就是说两个链表中，存在某一元素存储的地址是一致的），并且从这个地址之后的所有元素都相等。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>暴力解法：（c语言实现）</p><p>​个人第一次解的时候使用的方法，使用两个循环，查找地址相同的两个节点，并且指向的下一个地址也相同，则就是两个链表的交点。</p><p>巧妙解法：（C++实现）</p><ul><li>得出两个链表长度</li><li>计算链表长度差gap（C++中可以用swap（a，b），快速交换a和b的值）</li><li>长链表指针先移动gap位，使得两个链表尾部对齐</li><li>开始同时遍历长链表和短链表，找到相同的地址节点后返回</li></ul><p>这么做的话也就是说，两个链表要是相交的话，一定从短链表中的元素开始的。</p><p>c语言代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">getIntersectionNode</span><span class="params">(<span class="keyword">struct</span> ListNode *headA, <span class="keyword">struct</span> ListNode *headB)</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">    ListNode* B = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    B-&gt;next = headB;</span><br><span class="line">    ListNode* cur = B;</span><br><span class="line">    ListNode* ans = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(headA)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">if</span>((cur-&gt;next == headA-&gt;next) &amp;&amp; (cur == headA))&#123;<span class="comment">//是接下来的指向的位置相等，不是存储的数字相等</span></span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        headA = headA-&gt;next;</span><br><span class="line">        cur = B;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lenB = <span class="number">0</span>;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">while</span>(curB != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="keyword">if</span>(lenB&gt;lenA)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(lenA,lenB);<span class="comment">//快速交换两个元素的值</span></span><br><span class="line">            <span class="built_in">swap</span>(curA,curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> gap = lenA - lenB;</span><br><span class="line">        <span class="keyword">while</span>(gap)&#123;</span><br><span class="line">            gap--;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curA==curB)&#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA=curA-&gt;next;</span><br><span class="line">            curB=curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> 双指针法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除链表的倒数第N个节点</title>
      <link href="/2024/03/15/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>/2024/03/15/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h1><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/submissions/512403868/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题思路有二：</p><p>第一种：</p><p>自己的做法。</p><ul><li>使用虚拟头节点对链表进行反转操作</li><li>用cnt从前遍历n个，然后删除该节点</li><li>再次使用虚拟头节点对链表进行反转</li></ul><p>第二种：</p><p>双指针、虚拟头节点法做。</p><p>为什么要用虚拟头节点的方法做？</p><p>因为用虚拟头节点做的话可以不用考虑删除的元素是否为头节点。虚拟头节点一直指向的是链表的头节点的位置，就算链表的头结点变了，虚拟头节点还是可以link到新的头节点的位置。</p><ul><li>使用一个快指针前进n+1个节点</li><li>快、慢指针同时向前走，直到快指针遍历结束</li><li>此时慢指针指向n-1元素的位置，直接删除第n个元素即可</li></ul><p>以下c语言的做法就是用的第一种方法做的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">    ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    ListNode* temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">cout</span> =<span class="number">1</span>;</span><br><span class="line">    ListNode* phead = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    phead-&gt;next = pre;</span><br><span class="line">    cur = phead;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cout</span> == n)&#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>++;</span><br><span class="line">        cur = cur-&gt;next;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    cur = phead-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下c++代码实现第二种方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* phead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        phead-&gt;next = head;</span><br><span class="line">        ListNode* fast = phead;</span><br><span class="line">        ListNode* low = phead;</span><br><span class="line">        <span class="keyword">while</span>(n-- &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            low = low-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* temp = low-&gt;next;</span><br><span class="line">        low-&gt;next = low-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> 虚拟头节点 </tag>
            
            <tag> 双指针法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两两交换链表中的节点</title>
      <link href="/2024/03/14/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>/2024/03/14/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h1><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<img src="../%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/1.png" alt="1"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题目正常模拟就可以了。</p><p>建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。</p><p>做题时候记得先画图，按照图中指针指向的链路写代码就行。使用虚拟头节点的话，这个过程简单很多。注意一下，在交换完一次节点后，需要把虚拟头节点向后移动！一定要移动！</p><p>以下是c++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">ListNode* pre = <span class="keyword">new</span> ListNode;</span><br><span class="line"><span class="keyword">if</span> (pre == <span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line">pre-&gt;next = head;</span><br><span class="line">ListNode* cur = pre;</span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)&#123;</span><br><span class="line">ListNode* first = cur-&gt;next;</span><br><span class="line">ListNode* third = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line">cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">cur-&gt;next-&gt;next = first;</span><br><span class="line">cur-&gt;next-&gt;next-&gt;next = third;</span><br><span class="line">cur = cur-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">head = pre-&gt;next;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>c语言实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">swapPairs</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">ListNode* pre = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line"><span class="keyword">if</span> (pre == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line">pre-&gt;next = head;</span><br><span class="line">ListNode* cur = pre;</span><br><span class="line"><span class="keyword">while</span> ((cur-&gt;next)&amp;&amp; cur-&gt;next-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* temp1 = cur-&gt;next;<span class="comment">//1</span></span><br><span class="line">ListNode* temp = cur-&gt;next-&gt;next-&gt;next;<span class="comment">//3</span></span><br><span class="line">cur-&gt;next = cur-&gt;next-&gt;next;<span class="comment">//cur point 2</span></span><br><span class="line">cur-&gt;next-&gt;next = temp1; <span class="comment">//2 point 1</span></span><br><span class="line">temp1-&gt;next = temp;<span class="comment">//1 point 3</span></span><br><span class="line">        cur = cur-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">head = pre-&gt;next;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 链表 </tag>
            
            <tag> 模拟过程 </tag>
            
            <tag> 虚拟头节点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计链表</title>
      <link href="/2024/03/14/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
      <url>/2024/03/14/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h1><p><a href="https://leetcode.cn/problems/design-linked-list/description/">力扣</a></p><p>题意：</p><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>链表的增删查改实现。与之前学的数据结构<a href="https://xmuter.github.io/2024/03/02/%E7%BA%BF%E6%80%A7%E8%A1%A8List%E5%AD%A6%E4%B9%A0/">链表学习</a>不太一样。当时写了链表的创建、删除，认为增加和修改操作大同小异，就没有实践。知道做了这一题，才发现了许多没注意的细节问题。</p><p>链表问题，可以用数组、双指针的思路来解决。</p><p>​数组算是暴力解，先把链表中的值存在数组中，然后按照 规定取出组成新链表。</p><p>​双指针的话则要注意pre、cur指针，一定要平移，元素的位置不能动。总之，元素和指针只能动一个，不可以两个同时动，否则会被卷入循环漩涡，出不来结果。</p><p>​做题时一定要画图，把思路写出来，再实现代码，会对代码实现的逻辑有比较清楚的把控，debug的时候容易找出问题所在处。</p><p>​做题的时候要注意，头节点是否变动！！！（运行完函数后，是否有返回头节点）</p><p>以下是C语言实现设计链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyLinkedList</span>&#123;</span></span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyLinkedList</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; MyLinkedList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyLinkedList* <span class="title function_">myLinkedListCreate</span><span class="params">()</span> &#123;<span class="comment">//链表创建</span></span><br><span class="line">MyLinkedList* L = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">L-&gt;val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myLinkedListGet</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> index)</span> &#123;<span class="comment">//获取下标为index的节点值，没有返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">cout</span> = <span class="number">0</span>;</span><br><span class="line">obj = obj-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (obj)&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="built_in">cout</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> obj-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line">obj = obj-&gt;next;</span><br><span class="line"><span class="built_in">cout</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListAddAtHead</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> val)</span> &#123;<span class="comment">//插入至第一个元素之前</span></span><br><span class="line">MyLinkedList* first = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">first-&gt;val = val;</span><br><span class="line">first-&gt;next = obj-&gt;next;</span><br><span class="line">obj-&gt;next= first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListAddAtTail</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> val)</span> &#123;<span class="comment">//插入至最后一个元素之后</span></span><br><span class="line">MyLinkedList* last = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">last-&gt;val = val;</span><br><span class="line">last-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">MyLinkedList* cur;</span><br><span class="line">cur = obj-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">obj-&gt;next = last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (cur)&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">cur-&gt;next = last;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListAddAtIndex</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;<span class="comment">//将val插入下标index节点之前</span></span><br><span class="line">MyLinkedList* mid = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));<span class="comment">//没注意。如果index等于链表长度，则把val加在链表末端</span></span><br><span class="line">MyLinkedList* before = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">MyLinkedList* cur;</span><br><span class="line">MyLinkedList* pre = obj;</span><br><span class="line">mid-&gt;val = val;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="built_in">cout</span> = <span class="number">0</span>;</span><br><span class="line">cur = obj-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur)&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="built_in">cout</span>)</span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;next= mid;</span><br><span class="line">mid-&gt;next = cur;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>++;<span class="comment">//在cur指向NULL的时候，cout还加了1</span></span><br><span class="line">pre = cur;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == (<span class="built_in">cout</span>)&amp;&amp;flag)&#123;</span><br><span class="line">pre-&gt;next = mid;</span><br><span class="line">mid-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListDeleteAtIndex</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> index)</span> &#123;<span class="comment">//如果下标有效，删除下标为index的节点</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">cout</span> = <span class="number">0</span>;</span><br><span class="line">MyLinkedList* pre = obj;</span><br><span class="line">MyLinkedList* temp;</span><br><span class="line">MyLinkedList* cur;</span><br><span class="line"><span class="comment">//temp = obj-&gt;next;//第一个元素</span></span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>)&#123;</span><br><span class="line">temp = obj-&gt;next;</span><br><span class="line">obj-&gt;next = obj-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">cur = obj-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (index !=<span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="built_in">cout</span>)</span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;next = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>++;</span><br><span class="line">pre = cur;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListFree</span><span class="params">(MyLinkedList* obj)</span> &#123;<span class="comment">//释放链表所有元素</span></span><br><span class="line">MyLinkedList* cur;</span><br><span class="line">MyLinkedList* pre;</span><br><span class="line">cur = obj-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur)&#123;</span><br><span class="line">pre = cur;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(pre);</span><br><span class="line">&#125;</span><br><span class="line">pre = obj;</span><br><span class="line"><span class="built_in">free</span>(pre);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻转链表</title>
      <link href="/2024/03/13/%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2024/03/13/%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣</a></p><p>题意：反转一个单链表。</p><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用双指针法做。注意使用双指针法的时候，不要改变元素的位置，可以添加额外的指针来凑双指针。若改变元素位置来做，容易陷入死循环，导致做错。</p><p>C语言代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span>   </span><br><span class="line"><span class="comment">/* pre  cur   cur-&gt;next */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pre</span> =</span><span class="literal">NULL</span>;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur =temp;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> 双指针法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除链表元素</title>
      <link href="/2024/03/12/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
      <url>/2024/03/12/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h1><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素 - 力扣（LeetCode）</a></p><p>题意：删除链表中等于给定值 val 的所有节点。</p><p>示例 1： 输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6 输出：[1,2,3,4,5]</p><p>示例 2： 输入：head &#x3D; [], val &#x3D; 1 输出：[]</p><p>示例 3： 输入：head &#x3D; [7,7,7,7], val &#x3D; 7 输出：[]</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>随想录中使用两种方法移除链表元素。直接删除的方法如下。</p><p>2023.3.14补充：后续补充虚拟头节点的做法。假设一个虚拟头节点，指向head，通过虚拟头节点的不断移动来寻找相同的元素。此过程head没有变化。</p><p>做的过程中，直接删除的方法的难点在于：</p><ul><li>如何返回头节点。</li><li>如何把元素从上一个节点链接到下一个节点。</li></ul><p>C语言实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一 判断链表头结点是否为目标值，不是的话去掉</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">ListNode* after = <span class="literal">NULL</span>;</span><br><span class="line">ListNode* cur;<span class="comment">//构造一个参数，等于head</span></span><br><span class="line"><span class="keyword">while</span> (head &amp;&amp; head-&gt;val == val)&#123;<span class="comment">//判断头节点是否有val值，有的话去掉</span></span><br><span class="line">ListNode* temp = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">cur = head;<span class="comment">//一定是没有head值</span></span><br><span class="line"><span class="keyword">while</span> (cur)&#123;<span class="comment">//对cur进行操作，若为NULL，则说明已经遍历完节点</span></span><br><span class="line">after = cur-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (after &amp;&amp; after-&gt;val == val)&#123;<span class="comment">//要判断after是否存在</span></span><br><span class="line">cur-&gt;next = after-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(after);<span class="comment">//删除节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">ListNode* cur;</span><br><span class="line">ListNode* after;</span><br><span class="line">ListNode* temp;</span><br><span class="line"><span class="keyword">while</span> (head &amp;&amp; head-&gt;val == val)&#123;</span><br><span class="line">temp = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">cur = head;</span><br><span class="line"><span class="keyword">while</span> (cur)&#123;</span><br><span class="line">after = cur-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (after &amp;&amp; after-&gt;val == val)&#123;</span><br><span class="line">cur-&gt;next = after-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> after;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用虚拟头节点。。注意，使用虚拟头节点存储的头指针，在后续的指针操作中，若改变了链表中的头节点，虚拟头节点是始终指向链表的头结点的。</p><p>例如，虚拟头节点的next &#x3D; head；</p><p>​head由于临时指针（自己定义的一个指针，这个指针等于虚拟头节点，他们指向同一个位置）增删改变了，此时的next自动指向修改过后的head。</p><p>C语言实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">ListNode* pre = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="literal">NULL</span>)&#123;<span class="comment">//判断pre是否为空，若为空则直接返回报错。</span></span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line">pre-&gt;next = head;<span class="comment">// point to head</span></span><br><span class="line">ListNode* cur = pre;</span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next)&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">ListNode* temp = cur-&gt;next;</span><br><span class="line">cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">head = pre-&gt;next;<span class="comment">// delete old head ,pre will point new head auto.</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> 虚拟头节点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记</title>
      <link href="/2024/03/11/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/11/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h1><p>C语言中malloc是动态内存分配函数，C++中使用new关键字<br>函数原型：void *malloc(unsigned int num_bytes);</p><p>​void *malloc(sizeof（） * n);  </p><p>表示从堆山动态获取[sizeof（）*n] 大小的空间,</p><p> 其中，void*是泛指的指针类型。可以转换为任意指针类型的参数，一般与sizeof中的类型一致。例如：</p><p>​int* p &#x3D; （int*） malloc(sizeof（int） * n);  </p><p>参数：num_bytes 是无符号整型，用于表示分配的字节数。<br>返回值：如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。void 表示未确定类型的指针，void *可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据。<br>功能：分配长度为num_bytes字节的内存块<br>注意：当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。关于该函数的原型，在以前malloc返回的是char型指针，新的ANSIC标准规定，该函数返回为void型指针，因此必要时要进行类型转换。</p><h1 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h1>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>螺旋矩阵</title>
      <link href="/2024/03/11/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
      <url>/2024/03/11/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h1><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/submissions/510572866/">59. 螺旋矩阵 II - 力扣（LeetCode）</a></p><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><p>二维数组的构造，以及模拟过程的逻辑掌控。</p><p>C语言构建数组较为麻烦，C++则可以利用容器来构造数组。</p><p>还需要多复习多用C语言如何使用指针构造二维数组。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题目可以说在面试中出现频率较高的题目，<strong>本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。</strong></p><p>本题依然是要坚持循环不变量原则。</p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。</p><p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是<strong>一进循环深似海，从此offer是路人</strong>。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>关于二位数组的指针表示，以下为个人拙见：</p><p>​首先，数组使用指针表示的时候，其实是存储数组首位的地址。因为数组的存储地址是连续的。若是一维数组，则直接使用int<em>，存储数组首位地址就行。int</em>* 可表示二位数组，int*<em>指向 int</em>，int再指向存储的int。<br>​初始化时，先用<code>int** n = （int**）malloc（sizeof（int）n）；</code>先创建存储二维数组的n行空间；再用for循环，对 <code>*（n+i）= （int*）malloc（sizeof（int）*n）；</code>创建二位数组的n列空间。其中，*（n+i）表示从n向右移动的位数。</p><p>整体C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 使用vector定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 定义每循环一个圈的起始位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>; <span class="comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line">        <span class="type">int</span> mid = n / <span class="number">2</span>; <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span> (loop --) &#123;</span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">            <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; n - offset; j++) &#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; n - offset; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">            offset += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 O(n^2): 模拟遍历二维矩阵的时间</li><li>空间复杂度 O(1)</li></ul><p>c代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>** <span class="title function_">generateMatrix</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>* returnSize, <span class="type">int</span>* *returnColumnSizes)</span> &#123;</span><br><span class="line">*returnSize = n;</span><br><span class="line">*returnColumnSizes = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line"><span class="type">int</span>** ans = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * n);</span><br><span class="line"><span class="type">int</span> i; <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">ans[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">(*returnColumnSizes)[i] = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = n / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> loop = n / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> startx = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> starty = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> end = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (loop)&#123;</span><br><span class="line"><span class="keyword">for</span> ( j = starty; j &lt; n - end; j++)&#123;</span><br><span class="line">ans[startx][j] = num;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ( i = startx; i &lt; n - end; i++)&#123;</span><br><span class="line">ans[i][j] = num;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ( j = n - end; j &gt; starty; j--)&#123;</span><br><span class="line">ans[i][j] = num;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = n - end; i &gt; startx; i--) &#123;</span><br><span class="line">ans[i][j] = num;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">startx++;</span><br><span class="line">starty++;</span><br><span class="line">end++;</span><br><span class="line">loop--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">ans[mid][mid] = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> 模拟过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序数组的平方</title>
      <link href="/2024/03/10/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
      <url>/2024/03/10/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h1><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">力扣链接</a></p><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1：</p><ul><li>输入：nums &#x3D; [-4,-1,0,3,10]</li><li>输出：[0,1,9,16,100]</li><li>解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</li></ul><p>示例 2：</p><ul><li>输入：nums &#x3D; [-7,-3,2,3,11]</li><li>输出：[4,9,9,49,121]</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="暴力排序"><a href="#暴力排序" class="headerlink" title="暴力排序"></a>暴力排序</h3><p>最直观的想法，莫过于：每个数平方之后，排个序。本人于2024年3月9号尝试用c语言写过，奈何忘了排序算法该怎么写。以下C++代码抄自网上，有时间需要<strong>复习常见排序算法</strong>。C++实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            A[i] *= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>()); <span class="comment">// 快速排序</span></span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个时间复杂度是 O(n + nlogn)， 可以说是O(nlogn)的时间复杂度，但为了和下面双指针法算法时间复杂度有鲜明对比，我记为 O(n + nlog n)。</p><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><p>第一次尝试时遇到的问题：</p><p>​第一次看完双指针法的理论后去实践，从数组两边往中间逼近的方法进行排序，for循环里的条件是<code>for（int i；i&gt;=j；i--）</code>，i是数组最右边，j是数组最左边，然后比较它们，谁大谁幅值给ans[i]。这样做在运行时发现了许多问题，就是当 j&gt;i ，存完ans值后，直接i–。这意味着直接丢弃了nums[i]的值，是不对的。</p><p>C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size() ,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> index = nums.<span class="built_in">size</span>() <span class="number">-1</span>; index &gt;=<span class="number">0</span>; index --)&#123;</span><br><span class="line"><span class="type">int</span> rsquare = nums[right] * nums[right];</span><br><span class="line"><span class="type">int</span> lsquare = nums[left] * nums[left];</span><br><span class="line"><span class="keyword">if</span> (rsquare &gt;=lsquare)&#123;</span><br><span class="line">ans[index] = rsquare;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (lsquare &gt;rsquare)&#123;</span><br><span class="line">ans[index] = lsquare;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的时间复杂度为O(n)。</p><p>C语言实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">sortedSquares</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">*returnSize = numsSize;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = numsSize <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span>* ans = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * numsSize);</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> index =numsSize <span class="number">-1</span>; index &gt;= <span class="number">0</span>; index -- ) &#123;</span><br><span class="line"><span class="type">int</span> lsquare = nums[left] * nums[left];</span><br><span class="line"><span class="type">int</span> rsquare = nums[right] * nums[right];</span><br><span class="line"><span class="keyword">if</span> (rsquare &gt;= lsquare) &#123;</span><br><span class="line">ans[index] = rsquare;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rsquare &lt; lsquare) &#123;</span><br><span class="line">ans[index] = lsquare;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双指针法思路借鉴于<a href="https://www.programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> 双指针法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长度最小的子数组</title>
      <link href="/2024/03/10/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2024/03/10/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h1><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/submissions/509918082/">力扣链接</a></p><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><ul><li>输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</li><li>输出：2</li><li>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; target &lt;&#x3D; 10^9</li><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</li><li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>​使用两个for循环，然后不断的寻找符合条件的子序列，时间复杂度是O(n^2)。暴力解法在2024年3月10日没有试过。代码如下（copy至其他网友）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MAX; <span class="comment">// 最终的结果</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 子序列的数值之和</span></span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>; <span class="comment">// 子序列的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 设置子序列起点为i</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 设置子序列终止位置为j</span></span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s) &#123; <span class="comment">// 一旦发现子序列和超过了s，更新result</span></span><br><span class="line">                    subLength = j - i + <span class="number">1</span>; <span class="comment">// 取子序列的长度</span></span><br><span class="line">                    result = result &lt; subLength ? result : subLength;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>​滑动窗口就是使用两个指针（两个变量），其中一个指向靠后的数据，一个指向靠前的数据。靠前的指针一直向靠后的指针移动，直到条件满足为止。滑动窗口在数组中查找连续的数时使用较为灵活。</p><p>​所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环完成了一个不断搜索区间的过程。</p><p>那么滑动窗口如何用一个for循环来完成这个操作呢？</p><p>​首先要思考如果用一个for循环，那么应该表示滑动窗口的起始位置，还是终止位置。如果只用一个for循环来表示滑动窗口的起始位置，那么如何遍历剩下的终止位置？此时难免再次陷入暴力解法的怪圈。所以只用一个for循环，那么这个循环的索引，一定是表示滑动窗口的终止位置。</p><p>在本题中实现滑动窗口，主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p>窗口就是满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</p><p>解题的关键在于 窗口的起始位置如何移动，如图所示：</p><p><img src="../%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/2.png" alt="2"></p><p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。</strong></p><p>C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> min = INT32_MAX;<span class="comment">//取int32的最大值</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>; <span class="comment">//窗口起始点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">sum = sum + nums[i];</span><br><span class="line"><span class="keyword">while</span> (sum &gt;= target)&#123;</span><br><span class="line"><span class="type">int</span> minlength = i - j + <span class="number">1</span>;</span><br><span class="line">min = min &lt; minlength ? min : minlength;</span><br><span class="line">sum = sum - nums[j];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result = min == INT32_MAX ? <span class="number">0</span> : min;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>C代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line"><span class="type">int</span> min = INT32_MAX;</span><br><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">sum = nums[i] +sum;</span><br><span class="line"><span class="keyword">while</span> (sum &gt;=target)&#123;</span><br><span class="line"><span class="type">int</span> numlength = i - j + <span class="number">1</span>;</span><br><span class="line">min = numlength &lt; min ? numlength : min;</span><br><span class="line">sum = sum - nums[j];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result = (min == INT32_MAX) ? <span class="number">0</span> : min;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上对于滑动窗口的学习参考<a href="https://www.programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素</title>
      <link href="/2024/03/09/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2024/03/09/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h1><p><a href="https://leetcode.cn/problems/remove-element/">力扣链接</a></p><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1: 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p><p>示例 2: 给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p><strong>你不需要考虑数组中超出新长度后面的元素。</strong></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</strong></p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>这个题目暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。</p><p>删除过程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (val == nums[i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; numsSize <span class="number">-1</span>; j++)&#123;</span><br><span class="line">nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">i--;<span class="comment">//元素向左移动一位，因此i要重新判断是否与目标值一样</span></span><br><span class="line">numsSize = numsSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numsSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p>定义快慢指针</p><ul><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组（for循环遍历）</li><li>慢指针：指向更新 新数组下标的位置（数组下标++）</li></ul><p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p><p>C语言实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= numsSize<span class="number">-1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (val != nums[i]) &#123;</span><br><span class="line">nums[x] = nums[i];</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这些实现方法并没有改变元素的相对位置！</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val != nums[fastIndex]) &#123;</span><br><span class="line">                nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>双指针法思路借鉴于<a href="https://www.programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> 双指针法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2024/03/09/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2024/03/09/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h1><p><a href="https://leetcode.cn/problems/binary-search/description/">力扣链接</a></p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9     </span><br><span class="line">输出: 4       </span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4     </span><br></pre></td></tr></table></figure><p>1<br>2<br>3</p><p>示例 2:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2     </span><br><span class="line">输出: -1        </span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1        </span><br></pre></td></tr></table></figure><p>1<br>2<br>3</p><p>提示：</p><ul><li>你可以假设 nums 中的所有元素是不重复的。</li><li>n 将在 [1, 10000]之间。</li><li>nums 的每个元素都将在 [-9999, 9999]之间。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>这道题目的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p><p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p><p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p><p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p><p>下面二分写法区间定义为左闭右闭即[left, right]。</p><p><strong>二分查找的左区间left，是可以返回x&lt;target&lt;y中，x+1的下标的！</strong></p><p>c语言实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"><span class="type">int</span> right = numsSize - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;<span class="comment">// 防止溢出 等同于(left + right)/2</span></span><br><span class="line"><span class="keyword">if</span> (target &lt; nums[mid])&#123;</span><br><span class="line">right = mid - <span class="number">1</span>; <span class="comment">//mid  肯定不是目标值，所以右边界减1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">left = mid +<span class="number">1</span>; <span class="comment">//mid  肯定不是目标值，所以左边界加1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;<span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 未找到目标值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(log n)</li><li>空间复杂度：O(1)</li></ul><p>C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (right &gt;= left) &#123;</span><br><span class="line"><span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上学习参考<a href="https://www.programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6u开发学习笔记</title>
      <link href="/2024/03/06/imx6u%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/06/imx6u%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>mfgtool 上位机固化系统</strong></p><p>直接点击Mfgtool2-eMMC-ddr512-eMMC.vbs即可在线固化</p><p><strong>应用层操控硬件的两种方式</strong></p><p>在 Linux 系统下，一切皆文件！应用层如何操控底层硬件，同样也是通过文件 I&#x2F;O 的方式来实现。设备文件便是各种硬件设备向应用层提供的一个接口，应用层通过对设备文件的 I&#x2F;O 操作</p><p>控硬件设备，譬如 LCD 显示屏、串口、按键、摄像头等等，所以设备文件其实是与硬件设备相互对应的。设备文件通常在&#x2F;dev&#x2F;目录下，我们也把&#x2F;dev 目录下的文件称为设备节点。</p><p>设备节点并不是操控硬件设备的唯一途径，除此之外，我们还可以通过 sysfs 文件系统对硬件设备进行操控。</p><p><strong>sysfs</strong> <strong>文件系统</strong></p><p>sysfs 是一个基于内存的文件系统，同 devfs、proc 文件系统一样，称为虚拟文件系统。它的</p><p>作用是将内核信息以文件的方式提供给应用层使用。</p><p>系统中所有的设备（对象）都会在&#x2F;sys&#x2F;devices 体现出来，是 sysfs 文件系统中最重要的目录结构；而&#x2F;sys&#x2F;bus、&#x2F;sys&#x2F;class、&#x2F;sys&#x2F;dev 分别将设备按照挂载的总线类型、功能分类以及设备号的形式将设备组织存放在这些目录中，这些目录下的文件都是链接到了&#x2F;sys&#x2F;devices 中。</p><p>这里给大家进行一个总结，应用层想要对底层硬件进行操控，通常可以通过两种方式：</p><ul><li><p>&#x2F;dev&#x2F;目录下的设备文件（设备节点）；</p></li><li><p>&#x2F;sys&#x2F;目录下设备的属性文件。</p></li></ul><p>通常情况下，一般简单地设备会</p><p>​使用 sysfs 方式操控，其设备驱动在实现时会将设备的一些属性导出到用户空间 sysfs 文件系统，以属性文件的形式为用户空间提供对这些数据、属性的访问支持，譬如 LED、GPIO 等。但对于一些较复杂的设备通常会使用设备节点的方式，譬如 LCD 等、触摸屏、摄像头等。</p><p><strong>标准接口与非标准接口</strong></p><p> mkdir get 创建get文件夹</p><p> mount -t nfs -o nolock,nfsvers&#x3D;3 192.168.3.40:&#x2F;home&#x2F;alienteek&#x2F;linux&#x2F;nfs get&#x2F;</p><p>umount get&#x2F;&#x2F;卸载get目录</p><p>可执行文件运行起始地址（运行时候的位置，固定的）存储地址是可以变的</p><p>学习路线</p><p>uboot不学</p><p>Linux内核 裁剪移植 不学</p><p>先学 Linux应用开发基础知识第四</p><p>在学驱动开发基础知识第五</p><p>项目实战</p>]]></content>
      
      
      <categories>
          
          <category> 开源项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈Stack学习</title>
      <link href="/2024/03/04/%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/04/%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>​栈（Stack）是只允许在一端进行插入或删除的线性表。首先栈是一种线性表，但限定这种线性表<strong>只能在某一端进行插入和删除操作</strong>。</p><p><img src="../%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/1.png" alt="1"></p><p><strong>栈顶</strong>（Top）：线性表允许进行插入删除的那一端。<br><strong>栈底</strong>（Bottom）：固定的，不允许进行插入和删除的另一端。<br><strong>空栈</strong>：不含任何元素的空表。</p><p>栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构</p><h2 id="栈的常见基本操作"><a href="#栈的常见基本操作" class="headerlink" title="栈的常见基本操作"></a>栈的常见基本操作</h2><ul><li>InitStack(&amp;S)：初始化一个空栈S</li><li>StackEmpty(S)：判断一个栈是否为空，若栈为空则返回true，否则返回false</li><li>Push(&amp;S, x)：进栈（栈的插入操作），若栈S未满，则将x加入使之成为新栈顶</li><li>Pop(&amp;S, &amp;x)：出栈（栈的删除操作），若栈S非空，则弹出栈顶元素，并用x返回</li><li>GetTop(S, &amp;x)：读栈顶元素，若栈S非空，则用x返回栈顶元素</li><li>DestroyStack(&amp;S)：栈销毁，并释放S占用的存储空间（“&amp;”表示引用调用）</li></ul><h1 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h1><h2 id="栈的顺序存储"><a href="#栈的顺序存储" class="headerlink" title="栈的顺序存储"></a>栈的顺序存储</h2><p>​采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。<br>若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判断条件定位top等于-1。<br>​若现在有一个栈，StackSize是5，则栈的普通情况、空栈、满栈的情况分别如下图所示：</p><p><img src="../%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/2.1.png" alt="2.1"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>代码实现与顺序表的思路差不多。不过栈是后进先出。头文件如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;String&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> elemtype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">elemtype* elem;</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line">&#125;stack;</span><br></pre></td></tr></table></figure><p>实现的功能如下所示。进栈函数可改成动态的。若栈已满可扩容，思路与顺序表扩容一样。以下代码并未实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Initstack</span><span class="params">(stack&amp; S , <span class="type">int</span> size)</span></span>;<span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">stackempty</span><span class="params">(stack* S)</span></span>;<span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(stack* S, elemtype x)</span></span>;<span class="comment">//进栈，只能在顶层</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(stack* S, elemtype x)</span></span>;<span class="comment">//出栈,出顶层的</span></span><br><span class="line"><span class="function">elemtype <span class="title">gettop</span><span class="params">(stack* S)</span></span>;<span class="comment">//读取栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delstack</span><span class="params">(stack &amp;S)</span></span>;<span class="comment">//销毁栈，释放空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(stack* S)</span></span>;<span class="comment">//显示栈中元素</span></span><br></pre></td></tr></table></figure><p>函数具体细节如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Initstack</span><span class="params">(stack&amp; S, <span class="type">int</span> size)</span> </span>&#123;<span class="comment">//初始化栈</span></span><br><span class="line">S.elem = <span class="keyword">new</span> elemtype[size];</span><br><span class="line">S.size = size;</span><br><span class="line"><span class="keyword">if</span> (S.elem == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">S.top = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">stackempty</span><span class="params">(stack* S)</span> </span>&#123;<span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(stack* S, elemtype x)</span> </span>&#123;<span class="comment">//进栈，只能在顶层</span></span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == (S-&gt;size <span class="number">-1</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">S-&gt;top++;</span><br><span class="line">S-&gt;elem[S-&gt;top] = x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(stack* S, elemtype x)</span> </span>&#123;<span class="comment">//出栈,出顶层的</span></span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">x = S-&gt;elem[S-&gt;top];</span><br><span class="line">S-&gt;top--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">elemtype <span class="title">gettop</span><span class="params">(stack* S)</span> </span>&#123;<span class="comment">//读取栈顶元素</span></span><br><span class="line">elemtype x;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">x = S-&gt;elem[S-&gt;top];</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delstack</span><span class="params">(stack&amp; S)</span> </span>&#123;<span class="comment">//销毁栈，释放空间</span></span><br><span class="line">S.elem = <span class="literal">NULL</span>;</span><br><span class="line">S.top = <span class="number">-1</span>;</span><br><span class="line">S.size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">delete</span>[] S.elem;</span><br><span class="line"><span class="keyword">if</span> (S.elem == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(stack* S)</span> </span>&#123;<span class="comment">//显示栈中元素</span></span><br><span class="line"><span class="type">int</span> n = S-&gt;top;</span><br><span class="line"><span class="keyword">while</span> (n&gt;<span class="number">-1</span>)&#123;</span><br><span class="line">cout &lt;&lt; S-&gt;elem[n];</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试主代码如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">stack S;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Initstack</span>(S,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">stackempty</span>(&amp;S);</span><br><span class="line"> x = <span class="built_in">gettop</span>(&amp;S);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;top is : &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; input 4 num :&quot;</span> &lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="built_in">push</span>(&amp;S, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">display</span>(&amp;S);</span><br><span class="line"><span class="built_in">pop</span>(&amp;S,x);</span><br><span class="line"><span class="built_in">display</span>(&amp;S);</span><br><span class="line"><span class="type">bool</span> re = <span class="built_in">delstack</span>(S);</span><br><span class="line"><span class="keyword">if</span> (re == <span class="number">1</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;del success&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="../%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/3.png" alt="3"></p><h2 id="共享栈（两栈共享空间）"><a href="#共享栈（两栈共享空间）" class="headerlink" title="共享栈（两栈共享空间）"></a>共享栈（两栈共享空间）</h2><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​利用栈底位置相对不变的特征，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸，如下图所示：</p><p><img src="../%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/4.png" alt="4"></p><p>​两个栈的栈顶指针都指向栈顶元素，top0&#x3D;-1时0号栈为空，top1&#x3D;MaxSize时1号栈为空；仅当两个栈顶指针相邻（top0+1&#x3D;top1）时，判断为栈满。当0号栈进栈时top0先加1再赋值，1号栈进栈时top1先减一再赋值出栈时则刚好相反。</p><p>代码实现与顺序栈差不多。就是两个栈共享一段存储空间，元素入栈、出栈时需要判断对哪个栈进行操作。</p><h1 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h1><h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><p>​采用链式存储的栈称为链栈，链栈的优点是<strong>便于多个栈共享存储空间和提高其效率</strong>，且<strong>不存在栈满上溢</strong>的情况。通常采用单链表实现，并规定<strong>所有操作都是在单链表的表头进行</strong>。这里规定<strong>链栈没有头节点</strong>，<strong>Lhead指向栈顶元素</strong>，如下图所示。</p><p><img src="../%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/5.png" alt="5"></p><p>对于<strong>空栈</strong>来说，链表原定义是头指针指向空，那么链栈的空其实就是<strong>top&#x3D;NULL</strong>的时候。</p><h3 id="链栈进栈"><a href="#链栈进栈" class="headerlink" title="链栈进栈"></a>链栈进栈</h3><p>​对于链栈的进栈push操作，假设元素值为e的新节点是s，top为栈顶指针，示意图如下：</p><p><img src="../%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/6.1.png" alt="6.1"></p><h3 id="链栈的出栈"><a href="#链栈的出栈" class="headerlink" title="链栈的出栈"></a>链栈的出栈</h3><p>​链栈的出栈pop操作，也是很简单的三句操作。假设变量p用来存储要删除的栈顶结点，将栈顶指针下移以为，最后释放p即可，如下图所示：</p><p><img src="../%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/7.png" alt="7"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>​链栈的进栈相当于链表的前向插入，first in last out。以下代码思想主要是借鉴list链表的构建方法，使用head指针一直指向top。入栈时则head指向新的node，新的node的next指向之前的top。</p><p>头文件如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;String&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">Node* next;<span class="comment">//结构体指针</span></span><br><span class="line"><span class="type">int</span> cout;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><p>实现的函数如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initstack</span><span class="params">(Node *head)</span></span>;<span class="comment">//初始化栈</span></span><br><span class="line"><span class="function">Node* <span class="title">addnode</span><span class="params">(Node *head, <span class="type">int</span> data)</span></span>; <span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">display</span><span class="params">(Node* head, <span class="type">int</span> x)</span></span>;<span class="comment">//遍历打印链表,查找元素个数</span></span><br><span class="line"><span class="function">Node* <span class="title">findnode</span><span class="params">(Node* head, <span class="type">int</span> x)</span></span>;<span class="comment">//查找指针位置</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delnode</span><span class="params">(Node* head, <span class="type">int</span> n)</span></span>;<span class="comment">//出栈</span></span><br></pre></td></tr></table></figure><p>具体函数细节如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initstack</span><span class="params">(Node* head)</span> </span>&#123;<span class="comment">//初始化栈</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">head-&gt;cout = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">addnode</span><span class="params">(Node* head, <span class="type">int</span> data)</span> </span>&#123;<span class="comment">//入栈</span></span><br><span class="line">Node* s = <span class="keyword">new</span> Node; <span class="comment">// 分配结点新空间</span></span><br><span class="line">Node* tail = <span class="literal">NULL</span>;</span><br><span class="line">s-&gt;data = data;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;cout ==<span class="number">0</span>)&#123;</span><br><span class="line">head-&gt;next = s;</span><br><span class="line">s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">head-&gt;cout++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">s-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = s;</span><br><span class="line">head-&gt;cout++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">display</span><span class="params">(Node* head, <span class="type">int</span> x)</span> </span>&#123;<span class="comment">//遍历打印链表,查找元素个数</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">Node* p = head-&gt;next;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;链栈中的元素有：&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (p!= <span class="literal">NULL</span>) &#123;<span class="comment">//p本身就是指针变量</span></span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (x == p-&gt;data) &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">findnode</span><span class="params">(Node* head, <span class="type">int</span> x)</span> </span>&#123;<span class="comment">//查找指针位置</span></span><br><span class="line">Node* p = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (x == p-&gt;data) &#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delnode</span><span class="params">(Node* head, <span class="type">int</span> n)</span> </span>&#123;<span class="comment">//出栈</span></span><br><span class="line">Node* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p ==<span class="literal">NULL</span>)&#123;<span class="comment">//栈中没有元素</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">n = p-&gt;data;</span><br><span class="line">Node* after = p-&gt;next;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ssssss:   &quot;</span> &lt;&lt; after-&gt;data;</span><br><span class="line">head-&gt;next = after;</span><br><span class="line">head-&gt;cout--;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验截图如下所示</p><p><img src="../%E6%A0%88Stack%E5%AD%A6%E4%B9%A0/8.png" alt="8"></p><p><a href="https://blog.csdn.net/Real_Fool_/article/details/113852222">数据结构：栈和队列(Stack &amp; Queue)【详解】-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 顺序栈 </tag>
            
            <tag> 链栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表List学习</title>
      <link href="/2024/03/02/%E7%BA%BF%E6%80%A7%E8%A1%A8List%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/02/%E7%BA%BF%E6%80%A7%E8%A1%A8List%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表List"><a href="#线性表List" class="headerlink" title="线性表List"></a>线性表List</h1><p><img src="%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%88%86%E7%B1%BB.png" alt="线性表分类"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​List：零个或多个数据元素的有限序列。</p><p>​线性表的数据集合为{a1,a2,…,an}，假设每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素<strong>有且只有</strong>一个直接前驱元素，除了最后一个元素an外，每一个元素<strong>有且只有</strong>一个直接后继元素。数据元素之间的关系是一对一的关系。</p><p><img src="%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AE%9A%E4%B9%89.png" alt="线性表定义"></p><p>​在较复杂的线性表中，一个数据元素可以由若干个数据项组成。在这种情况下，常把数据元素称为<strong>记录</strong>，含有大量记录的线性表又称为<strong>文件</strong></p><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p><strong>概念</strong>：用一组<strong>地址连续</strong>的存储单元依次存储线性表的数据元素，这种存储结构的线性表称为顺序表。</p></li><li><p><strong>特点</strong>：<strong>逻辑</strong>上<strong>相邻</strong>的数据元素，<strong>物理次序</strong>也是<strong>相邻</strong>的。</p></li></ul><p>​只要确定好了存储线性表的起始位置，线性表中任一数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的储存结构，因为高级语言中的数组类型也是有随机存取的特性，所以通常我们都使用数组来描述数据结构中的顺序储存结构，用动态分配的一维数组表示线性表。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li><h4 id="头文件、链表结构体声明"><a href="#头文件、链表结构体声明" class="headerlink" title="头文件、链表结构体声明"></a>头文件、链表结构体声明</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;String&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">//一定要有这个，否则用不了cout</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> elemtype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">elemtype* elem;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;sqList;</span><br></pre></td></tr></table></figure><ul><li><h4 id="需要实现的函数列表（增删查改）"><a href="#需要实现的函数列表（增删查改）" class="headerlink" title="需要实现的函数列表（增删查改）"></a>需要实现的函数列表（增删查改）</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(sqList&amp; L, <span class="type">int</span> size)</span></span>;<span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_ListLength</span><span class="params">(<span class="type">const</span> sqList &amp;L)</span></span>;<span class="comment">//获取表长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Locate</span><span class="params">(<span class="type">const</span> sqList &amp;L ,<span class="type">const</span> elemtype &amp;e)</span></span>;<span class="comment">//按值查找</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Getdata</span><span class="params">(<span class="type">const</span> sqList&amp; L, <span class="type">int</span> i, elemtype &amp;e)</span></span>;<span class="comment">//获取第i个数据</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsList</span><span class="params">(sqList&amp; L, <span class="type">int</span> i,<span class="type">const</span> elemtype e )</span></span>;<span class="comment">//在第i个元素前插入一个元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DelList</span><span class="params">(sqList&amp; L, <span class="type">int</span> i, elemtype&amp; e)</span></span>;<span class="comment">//删除第i个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyList</span><span class="params">(sqList&amp; L)</span></span>;<span class="comment">//销毁顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearList</span><span class="params">(sqList&amp; L)</span></span>;<span class="comment">//清空顺序表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">emptyList</span><span class="params">(<span class="type">const</span> sqList&amp; L)</span></span>;<span class="comment">//判断顺序表是否为空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> sqList&amp; L)</span></span>;<span class="comment">//遍历顺序表，并输出</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="函数具体细节"><a href="#函数具体细节" class="headerlink" title="函数具体细节"></a>函数具体细节</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(sqList&amp; L, <span class="type">int</span> size)</span></span>&#123;<span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">0</span>) size = <span class="number">10</span>;</span><br><span class="line">L.elem = <span class="keyword">new</span> elemtype[size];</span><br><span class="line"><span class="keyword">if</span> (L.length == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">L.size = size;</span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_ListLength</span><span class="params">(<span class="type">const</span> sqList&amp; L)</span> </span>&#123;<span class="comment">//获取表长度</span></span><br><span class="line"><span class="keyword">if</span> (L.length == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Locate</span><span class="params">(<span class="type">const</span> sqList&amp; L, <span class="type">const</span> elemtype&amp; e)</span> </span>&#123;<span class="comment">//按值查找</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= L.length <span class="number">-1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (L.elem[i] == e)&#123;</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Getdata</span><span class="params">(<span class="type">const</span> sqList&amp; L, <span class="type">int</span> i,  elemtype&amp; e)</span> </span>&#123;<span class="comment">//获取第i个数据</span></span><br><span class="line"><span class="keyword">if</span> (i&gt;=<span class="number">1</span> &amp;&amp; i&lt;L.length)&#123;</span><br><span class="line">e = L.elem[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsList</span><span class="params">(sqList&amp; L, <span class="type">int</span> i, <span class="type">const</span> elemtype e)</span> </span>&#123;<span class="comment">//在第i个元素前插入一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (L.size == L.length)&#123;</span><br><span class="line">elemtype *temp = <span class="keyword">new</span> elemtype[<span class="number">2</span> * L.size];</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; L.length; b++)&#123;</span><br><span class="line">temp[b] = L.elem[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] L.elem;</span><br><span class="line">L.elem = temp;</span><br><span class="line">L.size = L.size * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> a = L.length <span class="number">-1</span>; a &gt;=i<span class="number">-1</span> ; a--)&#123;</span><br><span class="line">L.elem[a + <span class="number">1</span>] = L.elem[a];</span><br><span class="line">&#125;</span><br><span class="line">L.elem[i<span class="number">-1</span>] = e;</span><br><span class="line">L.length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DelList</span><span class="params">(sqList&amp; L, <span class="type">int</span> i, elemtype&amp; e)</span> </span>&#123;<span class="comment">//删除第i个元素</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">e = L.elem[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (a = i<span class="number">-1</span>; a &lt; L.length <span class="number">-1</span>; a++) &#123;</span><br><span class="line">L.elem[a] = L.elem[a+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">L.length--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyList</span><span class="params">(sqList&amp; L)</span> </span>&#123;<span class="comment">//销毁顺序表</span></span><br><span class="line"><span class="keyword">delete</span>[] L.elem;</span><br><span class="line">L.elem = <span class="literal">NULL</span>;</span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line">L.size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearList</span><span class="params">(sqList&amp; L)</span> </span>&#123;<span class="comment">//清空顺序表</span></span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">emptyList</span><span class="params">(<span class="type">const</span> sqList&amp; L)</span> </span>&#123;<span class="comment">//判断顺序表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (L.length == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> sqList&amp; L)</span> </span>&#123;<span class="comment">//遍历顺序表，并输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= L.length <span class="number">-1</span>; i++)&#123;</span><br><span class="line">cout &lt;&lt; L.elem[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​其中，InsList函数实现链表动态大小。若存入的数据的位置大于链表的size，则自动扩容2倍。</p><ul><li><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">sqList L;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">InitList</span>(L,<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;顺序表初始长度是：&quot;</span> &lt;&lt; <span class="built_in">get_ListLength</span>(L) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">InsList</span>(L, i, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;顺序表长度是：&quot;</span> &lt;&lt; <span class="built_in">get_ListLength</span>(L) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;顺序表大小是：&quot;</span> &lt;&lt; L.size &lt;&lt; endl;</span><br><span class="line"><span class="built_in">display</span>(L);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="type">bool</span> re = <span class="built_in">DelList</span>(L, <span class="number">2</span>,x);</span><br><span class="line"><span class="keyword">if</span> (re == <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="built_in">display</span>(L);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的元素是：&quot;</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;false&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Getdata</span>(L,<span class="number">3</span>,x);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;find的元素是：&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> y = <span class="built_in">Locate</span>(L,<span class="number">6</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;locate的元素是：&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4></li></ul><p><img src="../%E7%BA%BF%E6%80%A7%E8%A1%A8List%E5%AD%A6%E4%B9%A0/%E9%A1%BA%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%AE%9E%E9%AA%8C%E6%88%AA%E5%9B%BE.png" alt="顺序链表实验截图"></p><h2 id="顺序表优缺点"><a href="#顺序表优缺点" class="headerlink" title="顺序表优缺点"></a>顺序表优缺点</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>支持随机访问，可以通过下标来直接访问。</li><li>可以排序。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>中间&#x2F;头部的插入删除，时间复杂度为O(N)</li><li>增容需要申请新空间，拷贝数据，释放旧空间。会有不小的消耗。</li><li>增容一般是呈2倍的增长，势必会有一定的空间浪费。</li></ol><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h2><p>​链表是一种物理存储结构上<strong>非连续</strong>、<strong>非顺序</strong>的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p><p><img src="../%E7%BA%BF%E6%80%A7%E8%A1%A8List%E5%AD%A6%E4%B9%A0/%E9%93%BE%E8%A1%A8%E5%AE%9A%E4%B9%89.png" alt="链表定义"></p><p>​图中：2.3.4.5都是结构体，称之为<strong>结点</strong>Node，与顺序表不同的是，链表中的每个结点不是只单纯的存一个数据。而是一个结构体，结构体成员包括一个所存的数据，和下一个结点的地址。另外，顺序表中的地址是连续的，而<strong>链表中结点的地址是随机分配的</strong>。</p><p>​图中的phead指针中存放的是第一个结点的地址，那么根据指着地址我们就可以找到这个结构体，又因为这个结构体中存放了下一个结构体的地址，所以又可以找到第二个结构体，循环往复就可以找到所有的结点，直到存放空地址的结构体。因此结点由<strong>数据域</strong>和<strong>指针域</strong>构成。</p><p>notes：图中的箭头实际上是不存在的，这里只是为了能够方便理解。</p><p><strong>注意：</strong></p><ol><li>从图中可以看出，链式结构在逻辑上是连续的，但在物理上不一定连续。</li><li>现实中的结点一般都是从堆上申请出来的。</li><li>从堆上申请的空间，是按照一定的策略来分配的，两次申请的空间可能连续，也可能不连续。</li></ol><h2 id="链表分类"><a href="#链表分类" class="headerlink" title="链表分类"></a>链表分类</h2><h4 id="1-单向或者双向"><a href="#1-单向或者双向" class="headerlink" title="1. 单向或者双向"></a>1. 单向或者双向</h4><p>有head头指针，链表结尾指向NULL（尾结点）</p><p><img src="../%E7%BA%BF%E6%80%A7%E8%A1%A8List%E5%AD%A6%E4%B9%A0/%E9%93%BE%E8%A1%A8%E5%8D%95%E5%90%91%E6%88%96%E5%8F%8C%E5%90%91.png" alt="链表单向或双向"></p><h4 id="2-带头或不带头"><a href="#2-带头或不带头" class="headerlink" title="2.带头或不带头"></a>2.带头或不带头</h4><p><img src="../%E7%BA%BF%E6%80%A7%E8%A1%A8List%E5%AD%A6%E4%B9%A0/%E9%93%BE%E8%A1%A8%E5%B8%A6%E5%A4%B4%E6%88%96%E4%B8%8D%E5%B8%A6%E5%A4%B4.png" alt="链表带头或不带头"></p><h4 id="3-循环或非循环"><a href="#3-循环或非循环" class="headerlink" title="3.循环或非循环"></a>3.循环或非循环</h4><p>有head头指针，链表结尾指向第一个node的地址（尾结点）</p><p><img src="../%E7%BA%BF%E6%80%A7%E8%A1%A8List%E5%AD%A6%E4%B9%A0/%E5%BE%AA%E7%8E%AF%E6%88%96%E9%9D%9E%E5%BE%AA%E7%8E%AF.png" alt="循环或非循环"></p><h3 id="常用链表"><a href="#常用链表" class="headerlink" title="常用链表"></a>常用链表</h3><p><img src="../%E7%BA%BF%E6%80%A7%E8%A1%A8List%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E8%A7%81%E9%93%BE%E8%A1%A8.png" alt="常见链表"></p><ol><li>无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。</li><li>带头双向循环链表：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，实现反而简单了，后面我们代码实现了就知道了。</li></ol><h3 id="单向链表代码实现"><a href="#单向链表代码实现" class="headerlink" title="单向链表代码实现"></a>单向链表代码实现</h3><p>​代码实现单向链表的创建、删除、查找。增加、修改操作与删除操作大同小异。</p><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;String&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">Node* next;<span class="comment">//结构体指针</span></span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><h4 id="实现函数列表"><a href="#实现函数列表" class="headerlink" title="实现函数列表"></a>实现函数列表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">creatnode</span><span class="params">(<span class="type">int</span> n)</span></span>; <span class="comment">//创建链表</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">display</span><span class="params">(Node * head,<span class="type">int</span> x)</span></span>;<span class="comment">//遍历打印链表,查找元素个数</span></span><br><span class="line"><span class="function">Node* <span class="title">findnode</span><span class="params">(Node *head,<span class="type">int</span> x)</span></span>;<span class="comment">//查找指针位置</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delnode</span><span class="params">(Node* head , <span class="type">int</span> n)</span></span>;<span class="comment">//删除第n个结点</span></span><br></pre></td></tr></table></figure><h4 id="函数具体细节-1"><a href="#函数具体细节-1" class="headerlink" title="函数具体细节"></a>函数具体细节</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">creatnode</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;<span class="comment">//创建链表</span></span><br><span class="line">Node* s = <span class="literal">NULL</span>; <span class="comment">// 指向结点</span></span><br><span class="line">Node* head = <span class="literal">NULL</span>;</span><br><span class="line">Node* tail = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">s = <span class="keyword">new</span> Node;<span class="comment">//记得要申请内存，若不用内存要及时删除</span></span><br><span class="line"><span class="keyword">if</span> (s ==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = s;</span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">0</span>)&#123;</span><br><span class="line">head = s;</span><br><span class="line">tail = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tail-&gt;next = s;</span><br><span class="line">tail = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tail != <span class="literal">NULL</span>)&#123;</span><br><span class="line">tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">display</span><span class="params">(Node* head, <span class="type">int</span> x)</span> </span>&#123;<span class="comment">//遍历打印链表,查找元素个数</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">Node* p;</span><br><span class="line">p = head;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (x == p-&gt;data) &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">findnode</span><span class="params">(Node* head, <span class="type">int</span> x)</span> </span>&#123;<span class="comment">//查找指针位置</span></span><br><span class="line">Node* p = head;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (x == p-&gt;data)&#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delnode</span><span class="params">(Node* head , <span class="type">int</span> n)</span> </span>&#123;<span class="comment">//删除第n个结点</span></span><br><span class="line">Node* p = head;</span><br><span class="line">Node* before = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n<span class="number">-2</span>; i++)&#123;<span class="comment">//n-1是要删除的结点，n-2的时候就指向该结点了</span></span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (i==n<span class="number">-3</span>)&#123;</span><br><span class="line">before = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Node* temp = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (before != <span class="literal">NULL</span>)&#123;</span><br><span class="line">before-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表遍历图例"><a href="#链表遍历图例" class="headerlink" title="链表遍历图例"></a>链表遍历图例</h4><p><img src="../%E7%BA%BF%E6%80%A7%E8%A1%A8List%E5%AD%A6%E4%B9%A0/%E9%93%BE%E8%A1%A8%E9%81%8D%E5%8E%86.png" alt="链表遍历"></p><h4 id="链表创建图例"><a href="#链表创建图例" class="headerlink" title="链表创建图例"></a>链表创建图例</h4><p><img src="../%E7%BA%BF%E6%80%A7%E8%A1%A8List%E5%AD%A6%E4%B9%A0/%E9%93%BE%E8%A1%A8%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%A7%A3%E9%87%8A%E5%9B%BE.png" alt="链表创建过程解释图"></p><h5 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h5><p><a href="https://www.bilibili.com/video/BV1kt4y1Y77s/?spm_id_from=333.788.recommend_more_video.2&vd_source=cef6c560be7d77dc23c39f07ef4b9a85">bilibili</a></p><h4 id="测试主函数"><a href="#测试主函数" class="headerlink" title="测试主函数"></a>测试主函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">Node *head = <span class="built_in">creatnode</span>(n);</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">display</span>(head,<span class="number">2</span>);</span><br><span class="line">Node* find = <span class="built_in">findnode</span>(head , <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;查找2的个数有：&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;元素3所在的位置是：&quot;</span> &lt;&lt; find &lt;&lt; endl;</span><br><span class="line"><span class="built_in">delnode</span>(head, <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除第三个元素后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">display</span>(head, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="../%E7%BA%BF%E6%80%A7%E8%A1%A8List%E5%AD%A6%E4%B9%A0/1.png" alt="1"></p><h3 id="顺序表和链表区别"><a href="#顺序表和链表区别" class="headerlink" title="顺序表和链表区别"></a>顺序表和链表区别</h3><table><thead><tr><th>不同点</th><th>顺序表</th><th>链表</th></tr></thead><tbody><tr><td>存储空间上</td><td>物理上一定连续</td><td>逻辑上连续，但物理上不一定连续</td></tr><tr><td>随机访问</td><td>支持O(1）</td><td>不支持：O(N)</td></tr><tr><td>任意位置插入或者删除元素</td><td>可能需要搬移元素，效率低O(N)</td><td>只需修改指针指向</td></tr><tr><td>插入</td><td>动态顺序表，空间不够时需要扩容</td><td>没有容量的概念</td></tr><tr><td>应用场景</td><td>元素高效存储+频繁访问</td><td>任意位置插入和删除频繁</td></tr><tr><td>缓存利用率</td><td>高</td><td>低</td></tr></tbody></table><p>参考：</p><p><a href="https://blog.csdn.net/Zhupeizhao/article/details/105981523">嵌入式常见的数据结构_嵌入式数据结构-CSDN博客</a></p><p><a href="https://blog.csdn.net/Real_Fool_/article/details/113852222">数据结构：栈和队列(Stack &amp; Queue)【详解】-CSDN博客</a></p><p><a href="https://blog.csdn.net/Edward_Asia/article/details/120876314">【数据结构】链表(单链表实现+详解+原码)-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_35664104/article/details/120769681">数据结构–链表入门超详细解析(简单易懂纯原篇)_链表教学-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_35664104/article/details/120769681">数据结构–链表入门超详细解析(简单易懂纯原篇)_链表教学-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 链表 </tag>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MFC设计笔记</title>
      <link href="/2024/02/28/MFC%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/02/28/MFC%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MFC界面教程"><a href="#MFC界面教程" class="headerlink" title="MFC界面教程"></a><strong>MFC界面教程</strong></h1><h2 id="前言"><a href="#前言" class="headerlink" title="*前言*"></a><em><strong>*前言*</strong></em></h2><p>本教程分为四部分：</p><ol><li><p>创建工程</p></li><li><p>初步设计界面</p></li><li><p>编写控制代码（使用dll动态链接库）</p></li><li><p>美化界面</p></li></ol><p>每个部分都有详细的步骤（第一步、第二步、第三步…..），在每部分的结尾都有一些可能会遇到的问题的<em><strong>*解决办法，可供参考。*</strong></em></p><p>本次使用的软件为Visual Studio 2019（以下简称vs）。</p><p>-——————————————————————————————————————————–</p><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="*创建工程 *"></a><em><strong>*创建工程 *</strong></em></h2><p><strong>第一步</strong>：打开已经安装好的vs，点击创建新项目，如图1所示。</p><p><img src="%E5%9B%BE%E7%89%871.png" alt="img"> </p><p>​图1</p><p><strong>第二步</strong>：如图2所示，点击搜索框，输入MFC，然后回车，选择MFC应用后，点击下一步。</p><p><img src="%E5%9B%BE%E7%89%872.png" alt="img"> </p><p>​图2</p><p><strong>第三步</strong>：如果上一步没问题的话我们这时会看到配置新项目的窗口，这里我们把项目名称改成自己想要的名字，保存的位置可自己选择，设置好后点击创建。这里项目名称设置为MFC_APP，如图3所示。</p><p><img src="%E5%9B%BE%E7%89%873.png" alt="img"> </p><p>​图3</p><p><strong>第四步</strong>：要是第三步没问题的话我们会看到MFC应用程序类型选项。应用程序类型选择基于对话框。如图4.1所示。</p><p><img src="%E5%9B%BE%E7%89%874.png" alt="img"> </p><p>​图4.1</p><p>在用户界面功能中可根据需要添加主框架样式。这里添加最大化框和最小化框，如图4.2所示。</p><p><img src="%E5%9B%BE%E7%89%875.png" alt="img"> </p><p>​图4.2</p><p>点击生成的类，把生成的类改成Dlg后，点击完成，即可创建一个新的MFC工程，如图4.3所示。</p><p><img src="%E5%9B%BE%E7%89%876.png" alt="img"> </p><p>​图4.3</p><p>生成好的界面如图4.4所示。</p><p><img src="%E5%9B%BE%E7%89%877.png" alt="img"> </p><p>​图4.4</p><p><strong>第五步</strong>：如图4.5所示,把x86改成x64后，点击调试—&gt;开始调试，测试一下是否有问题。</p><p><img src="%E5%9B%BE%E7%89%878.png" alt="img"> </p><p>​图4.5</p><p><strong>第六步</strong>：点击资源视图—&gt;xxx.re—-&gt;Dialog—-&gt;双击IDO_xxx_DIALOG（xxx是你的工程文件名），即可得到图4.6所示界面</p><p><img src="%E5%9B%BE%E7%89%879.png" alt="img"> </p><p>​图4.6</p><p>&lt;1&gt;如果无法建立工程文件，请检查是否安装了对应的组件，如图5所示。</p><p><img src="%E5%9B%BE%E7%89%8710.png" alt="img"> </p><p>​图5</p><p>已经安装好vs后，修改组件的方法参考以下链接： <a href="https://www.jb51.net/softjc/721800.html">VS已安装组件怎么更改? visual studio更改程序组件的技巧_编程开发_软件教程_脚本之家 (jb51.net)</a></p><p>&lt;2&gt;如果创建文件后没有跳转到图4.4所示界面，可手动打开创建的工程文件，点击调试—&gt;开始调试，测试一下工程文件是否正常。若正常则可继续操作。若不正常请百度解决。</p><h2 id="初步设计界面"><a href="#初步设计界面" class="headerlink" title="*初步设计界面*"></a><em><strong>*初步设计界面*</strong></em></h2><p><strong>第一步</strong>：按照图6所示，鼠标左击TODO，然后按下键盘上的删除按键(Del)。</p><p><img src="%E5%9B%BE%E7%89%8711.png" alt="img"> </p><p>​图6</p><p><strong>第二步</strong>：点击工具箱，添加你想要的控件，这里我们添加Button、Check Box、Edit Control、Static Text。可以左击已经添加的控件，修改其名字。左击控件，在右下角的属性栏中的杂项可以修改其ID，如图7.1所示。</p><p><img src="%E5%9B%BE%E7%89%8712.png" alt="img"> </p><p>​图7.1</p><p>点击添加的Edit Control控件（作为显示窗口的那个），修改其属性，把其ID设置为IDC_EtStatuShow如图7.2所示。</p><p><img src="%E5%9B%BE%E7%89%8713.png" alt="img"> </p><p>​图7.2</p><p>设计好的界面如图7.3所示（界面不唯一，可根据实际需要进行修改）</p><p><img src="%E5%9B%BE%E7%89%8714.png" alt="img"> </p><p>​图7.3</p><p>点击脉宽设置旁的Edit Control控件（如图所示），修改其ID为IDC_PulseSet（修改方法如图7.1所示）。修改完成后再次左击该控件，在该控件上右击，点击添加变量，将类别改为值，名称改为如图7.4所示，变量类型改为int。</p><p><img src="%E5%9B%BE%E7%89%8715.png" alt="img"> </p><p>​图7.4</p><p>同理，将剩余的Edit Control控件都按照图7.5的方法修改，把名称、变量类型分别改为：int m_FreqSet;(帧频设置)int m_MenMag;（灰度等级）int m_FrameSet;（帧数设置）float m_ShowTime;（积分时间）int m_MemWrAdr;（写地址设置）int m_MenRdAdr;（读地址设置）</p><p>其中，作为显示窗口的控件的修改如图7.5所示。</p><p><img src="%E5%9B%BE%E7%89%8716.png" alt="img"> </p><p>​图7.5</p><p>完成以上操作后，点击运行，检验是否有问题。若无问题进行下一步，如有问题请仔细阅读以上操作方法，还是无法解决请百度哈。</p><h2 id="编写控制代码"><a href="#编写控制代码" class="headerlink" title="*****编写控制代码*"></a>****<em><strong>*编写控制代码*</strong></em></h2><p><strong>第一步</strong>：双击需要添加控制代码的控件（这里点击USB初始化），即可自动打开.cpp文件。这里是编写控制MFC功能代码的地方。</p><p><strong>第二步</strong>：把我们事先生成的dll文件拷贝到工程文件中，若找不到工程文件在哪，可以如图8所示操作。</p><p><img src="%E5%9B%BE%E7%89%8717.png" alt="img"> </p><p>​图8</p><p><strong>第三步</strong>：在第一步打开的.cpp中编写代码:</p><p>​<code>HINSTANCE m_hDll = LoadLibrary(L&quot;xxx.dll&quot;);</code></p><p>其中，xxx是需要修改的。修改成你的dll文件名。点击运行，看是否出错。若出错，请确认生成的dll文件是否是64位的，此工程的Debug是否修改成X64。若有其他问题请百度。</p><p><strong>第四步</strong>：引用dll里函数的方法：</p><p>语句1：</p><p>​<code>typedef char* (*AddFun)(int a, int b);//(int a, int b)根据引入函数所需要的参数修改</code></p><p>语句2：</p><p>​<code>AddFun xxx = (AddFun)GetProcAddress(m_hDll, &quot;xxx&quot;);//xxx为要引入的函数</code></p><p>Notes：</p><ul><li><p>语句1中的定义(int a, int b)需要根据dll库中的函数形式进行修改，否则会出错。</p></li><li><p>语句2中要引入的函数为dll文件库中的函数名，”xxx”里不能有空格存在，否则会找不到需要调用的函数。</p></li></ul><p>图9.1是实现usb初始化函数的写法，可参考。</p><p><img src="%E5%9B%BE%E7%89%8718.png" alt="img"> </p><p>​图9.1</p><p>其中str、str1都是CString类型的变量，flag1是int类型的变量。写好后点击运行，要是前面都没问题，运行后点击USB初始化按钮会得到图9.2所示结果。</p><p><img src="%E5%9B%BE%E7%89%8719.png" alt="img"> </p><p>​图9.2</p><p>同理，可对其余控件进行相应的代码编写。</p><p><strong>4、</strong><em><strong>*如何美化界面？*</strong></em></p><p>参考<a href="https://blog.csdn.net/u011711997/category_6415897.html">用MFC做漂亮界面_孟建行的博客-CSDN博客</a></p><p>该链接中的教程十分详细,这里仅对该链接中的教程进行补充说明,建议先看完以下的补充说明后再去看参考博客。</p><p>MFC中添加函数的方法一：如图10.1所示，鼠标放在设计的MFC应用界面上任意位置，右击，点开类向导。</p><p><img src="%E5%9B%BE%E7%89%8720.png" alt="img"> </p><p>​图10.1</p><p>打开类向导后点击消息，找到消息里你想要找的名字（这里以WM_CTLCOLOR为例），然后双击，你会发现在现有的处理程序中出现了一个新的函数名，如图10.2所示。</p><p><img src="%E5%9B%BE%E7%89%8721.png" alt="img"> </p><p>​图10.2</p><p>点击图10.2中新出现的函数名后，点击编辑代码，即可对其进行代码编写。</p><p>MFC中添加函数的方法二：首先，如图10.3所示，找到类视图总的类。</p><p><img src="%E5%9B%BE%E7%89%8722.png" alt="img"> </p><p>​图10.3</p><p>找到你所要添加函数的类后，鼠标右键点击该类，会有一个添加—&gt;添加函数的选项。如图10.4所示。</p><p><img src="%E5%9B%BE%E7%89%8723.png" alt="img"> </p><p>​图10.4</p><p>打开添加函数后，即可添加函数名（函数的名字要包含定义的变量类型，例如SetImagePath(CString strImgPath, CString strParentImgPath)）。反回类型如果没有找到你想要的，可以先不管，创建好后在.cpp中和.h中手动修改即可。</p><p>创建类的方法：在设计的MFC界面上任意位置右击–&gt;添加类即可。注意添加类的开头缩写字母一定要比xxxDlg.cpp的排列顺序后（例如TEXT_Dlg.cpp，如果要添加类的话，类的名字的开头字母只能从U到Z中取），否则发送工程给其他人时会出错。</p>]]></content>
      
      
      <categories>
          
          <category> 项目类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 上位机设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源车载终端计划</title>
      <link href="/2024/02/26/%E5%BC%80%E6%BA%90%E8%BD%A6%E8%BD%BD%E7%BB%88%E7%AB%AF%E8%AE%A1%E5%88%92/"/>
      <url>/2024/02/26/%E5%BC%80%E6%BA%90%E8%BD%A6%E8%BD%BD%E7%BB%88%E7%AB%AF%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="调研阶段"><a href="#调研阶段" class="headerlink" title="调研阶段"></a>调研阶段</h2><p>​项目依据：<a href="https://blog.csdn.net/black_sneak/article/details/131889750">智能车载终端</a></p><h2 id="学习要点"><a href="#学习要点" class="headerlink" title="学习要点"></a>学习要点</h2><ul><li>Linux下嵌入式c开发</li><li>qt界面开发</li><li>加入摄像头，实现特定时刻显示（模拟倒车时，可看车后画面）</li><li>加入WiFi模块，实现联网。</li></ul><h2 id="项目时间预算"><a href="#项目时间预算" class="headerlink" title="项目时间预算"></a>项目时间预算</h2><p>2024年3月1日 - 2024年6月15日</p><h2 id="具体时间安排"><a href="#具体时间安排" class="headerlink" title="具体时间安排"></a>具体时间安排</h2><table><thead><tr><th align="center">时间</th><th align="center">计划</th></tr></thead><tbody><tr><td align="center">2024.3.1-2024.3.31</td><td align="center">学习Linux下C开发，qt开发</td></tr><tr><td align="center">2024.4.1-2024.4.30</td><td align="center">完成qt界面开发</td></tr><tr><td align="center">2024.5.1-2024.5.31</td><td align="center">完成加入摄像头，wifi模块开发</td></tr><tr><td align="center">2024.6.1-2024.6.15</td><td align="center">完成项目技术梳理以及总结</td></tr></tbody></table><h2 id="各阶段计划具体说明"><a href="#各阶段计划具体说明" class="headerlink" title="各阶段计划具体说明"></a>各阶段计划具体说明</h2><ol><li>c开发：熟悉嵌入式Linux c应用开发流程，能够实现裸机跑程序。</li><li>qt开发：实现音乐播放、文件管理、相册、视频播放器、天气监视、壁纸切换、地图、系统设置</li><li>加入摄像头：实现倒车影像实时获取</li><li>wifi模块：实现实时联网</li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spyglass学习</title>
      <link href="/2024/02/26/spyglass%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/02/26/spyglass%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spyglass介绍"><a href="#1-Spyglass介绍" class="headerlink" title="1 Spyglass介绍"></a>1 Spyglass介绍</h1><p>​SpyGlass是目前业界唯一可靠的RTL Sign off解决方案，可以帮助客户在设计早期发现潜在问题，保证产品质量，极大的减少设计风险, 降低设计成本。SpyGlass已经成为集成电路开发过程中必不可少的RTL-QA工具。SpyGlass作为第三代RTL代码质量分析工具的领导者, 已经被全世界的IC设计公司和IP公司广泛采用。</p><h2 id="1-1-Spyglass技术领先优势"><a href="#1-1-Spyglass技术领先优势" class="headerlink" title="1.1 Spyglass技术领先优势"></a>1.1 Spyglass技术领先优势</h2><ul><li>业界唯一公认的RTL sign off解决方案</li><li>软IP出厂质量检验必备工具</li><li>TSMC IP 9000 采用SpyGlass</li><li>业界检查规则最全的检查工具，内含5000余条设计的规则</li><li>业界最全面的多时钟域CDC检查机制</li><li>业界最快速的早期DFT检查方法学</li><li>业界最先进的早期低功耗解决方案</li><li>业界唯一的SDC检查工具</li><li>可与设计流程上其它环节EDA工具无缝连接</li><li>支持深亚微米设计规则</li></ul><h2 id="1-2-SpyGlass子模块介绍"><a href="#1-2-SpyGlass子模块介绍" class="headerlink" title="1.2 SpyGlass子模块介绍"></a>1.2 SpyGlass子模块介绍</h2><ul><li>SpyGlass-Lint<ul><li>支持多种规则检查，能发现诸如Latch等代码质量问题。</li></ul></li><li>SpyGlass-CDC<ul><li>支持所有常见的同步器；自动识别设计中复杂的握手信号和FIFO同步机制并对其进行形式验证；自动识别gray-code逻辑和re-convergent信号并对其进行形式验证。用户不需要提供任何的仿真激励和assertions来测试CDC问题，工具自动生成并进行CDC分析。</li></ul></li><li>SpyGlass-Power<ul><li>帮助用户管理复杂的多电源和电压域：它可以验证、显示和分析多个域之间的串扰问题，并且自动修复功能可以自动的插入level-shifter和isolation逻辑。SpyGlass-Power是包括针对时钟、数据通路控制、总线和内存单元的一套完全的技术。SpyGlass-Power的最新功能还包括基于RTL代码的功耗估计和最优门控时钟设计建议。</li></ul></li><li>SpyGlass-DFT<ul><li>包括丰富的、超过100条DFT设计规则。这些包括时钟规则、锁存器规则、布局规则、三态规则、RAM规则、扫描链规则等。SpyGlass-Test包括At-speed覆盖率预测，因此它能明确的指出今后测试的瓶颈。它不仅能报告覆盖率，还能描述出覆盖率低的原因。它统一的自动修复能力自动的更正很多扫描出的问题。</li></ul></li><li>SpyGlass-Constraints<ul><li>自动生成对应RTL或网表的SDC以及时序异常约束；自动对时序异常进行形式验证；精确的查明SDC的语法、一致性和完整性问题，包括模块内部的、模块之间的，以及模块和整个芯片之间。SpyGlass-Constraints可以把模块级的SDC合并成芯片级的SDC；检测出SDC的不同版本和针对不同工具、不同设计阶段的SDC存在的问题。</li></ul></li></ul><p>以上构成分析RTL问题的完整平台，全面的解决RTL设计中所存在的各方面问题。</p><h2 id="1-3-Spyglass基本概念"><a href="#1-3-Spyglass基本概念" class="headerlink" title="1.3 Spyglass基本概念"></a>1.3 Spyglass基本概念</h2><p>对于Spyglass，我们先要知晓一些基本概念:</p><ul><li><strong>Rule</strong>: 是SpyGlass 进行RTL分析的最小单位。</li><li><strong>Goal</strong>: 是一系列相关Rule的集合,组合起来完成RTL分析的某个特定任务. user可以用GuideWare定义好的Goal, 也可根据工程项目要求来选择一系列rule的集合形成自定义 GUI里面点Goal的button来选择设定, 也可在Prj file 里定义。</li><li><strong>Sub-Methodology</strong>: 是一系列相关Goal的集合, 用以达成某方面特定目标, 如完成CDC check。</li><li><strong>SGDC</strong>: Constraints 文件, 主要包含clock和reset等约束信息。</li><li><strong>Waiver</strong>: 用以过滤一些结果的文件。</li><li><strong>Severity</strong>: report结果中分Fatal, Error, Warning和INFO四等级信息。</li><li><strong>Parameter</strong>: 可以在进行RTL分析之前设定某些参数, 对检查过程进行一些约束。</li></ul><h2 id="1-4-Spyglass流程阶段"><a href="#1-4-Spyglass流程阶段" class="headerlink" title="1.4 Spyglass流程阶段"></a>1.4 Spyglass流程阶段</h2><p>Spyglass的原理流程分为三个阶段：设置阶段、目标和运行阶段、分析结果阶段，如下所示：</p><p><img src="spyglass%E5%9B%BE1.png" alt="spyglass图1"></p><h1 id="2-Spyglass界面操作"><a href="#2-Spyglass界面操作" class="headerlink" title="2 Spyglass界面操作"></a>2 Spyglass界面操作</h1><h2 id="2-1-读取设计文件"><a href="#2-1-读取设计文件" class="headerlink" title="2.1 读取设计文件"></a>2.1 读取设计文件</h2><p>（1）Linux的terminal输入spyglass &amp;，这便打开了Spyglass工具的图形界面。</p><p>（2）点击工具左侧的“Add Files”，加载设计文件。</p><p><img src="spyglass%E5%9B%BE2.png" alt="spyglass图2"></p><p>（3）弹出的选中界面选中所需的Verilog文件，如果准备好了filelist，可以直接选中filelist，然后点击Add按钮</p><p><img src="spyglass%E5%9B%BE3.png" alt="spyglass图3"></p><p>此时Spyglass界面下方的sg_shell界面会打印出读取到文件的相关信息：</p><p><img src="spyglass%E5%9B%BE4.png" alt="spyglass图4"></p><h2 id="2-2-设置顶层模块"><a href="#2-2-设置顶层模块" class="headerlink" title="2.2 设置顶层模块"></a>2.2 设置顶层模块</h2><p>（1）点击“Set Options”，然后双击“Top Level Design Unit”的Value框，输入顶层模块名“uart_top”，再敲回车。</p><p><img src="spyglass%E5%9B%BE5.png" alt="spyglass图5"></p><h2 id="2-3-编译设计"><a href="#2-3-编译设计" class="headerlink" title="2.3 编译设计"></a>2.3 编译设计</h2><p>先点击上方的“Read Design”，再点击左侧的“Run Design Read”，开始进行文件编译和分析，结果见下方窗口。</p><p><img src="%E5%9B%BE6.png" alt="图6"></p><p>这次的文件编译没有问题，界面中的Instances出现了目录结构，都是绿色的。</p><p>如果文件不存在，则会报错提醒，同时Instances里的对应文件会变成黑色。Instance下文件的颜色含义如下：</p><ul><li>绿色表示已准备好进行分析但尚未在内部综合；</li><li>黑色表示无法分析该块（黑框）；</li><li>白色表示该模块是可综合的；</li></ul><h2 id="2-4-静态分析lint"><a href="#2-4-静态分析lint" class="headerlink" title="2.4 静态分析lint"></a>2.4 静态分析lint</h2><p>Lint分析不要求完整的工程文件，因此非常方便分工合作，每个人只负责自己这部分的检查即可。</p><p>（1）先点击上面的“Goal Setup”，然后选中lint下的lint_rtl，最后点击“Run Goal”。</p><p><img src="%E5%9B%BE7.png" alt="图7"></p><p><strong>注意：</strong>如果有特殊需求，可以在lint_rtl里右键选择Edit Rules and Parameters来修改或waive规则。</p><p>（2）下方窗口显示出了分析结果，这里是出现了一个Latch，双击该警告会跳转到出问题的代码。思考后发现这里用了组合逻辑，但if后没有跟else，因此出现了锁存器。</p><p><img src="%E5%9B%BE8.png" alt="图8"></p><p>（3）红色信息表示错误，橙色信息表示警告，绿色信息表示正常。</p><p>（4）选中违规信息，右键选择Waive Selected Messages可以忽略掉某种类型的检查。</p><p>（5）点击方框中的类似图像界面的符号，还可以查看设计的电路原理图</p><h2 id="2-5-状态机完整性分析"><a href="#2-5-状态机完整性分析" class="headerlink" title="2.5 状态机完整性分析"></a>2.5 状态机完整性分析</h2><p>Spyglass还可以用于检查状态机的完整性，这里重新建立工程，引入一个写有状态机的Verilog。</p><h3 id="（1）编辑sgdc文件"><a href="#（1）编辑sgdc文件" class="headerlink" title="（1）编辑sgdc文件"></a>（1）编辑sgdc文件</h3><p>做状态机的结构完备性检查时，需要用到Spyglass 的工程约束文件，叫做SGDC，这是一种类似SDC的约束文件，全称是：Spyglass Design Constraints。</p><p>新建一个spyglass.sgdc文件，内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#当前设计工程，需要填写 top 模块名称:FSM_3</span><br><span class="line">current_design FSM_3</span><br><span class="line">#当前模块的时钟周期约束，使用模块名.时钟方式索引</span><br><span class="line">clock -name FSM_3.clk -period 10</span><br><span class="line">#当前模块的复位信号，0是低电平有效，1是高电平有效</span><br><span class="line">reset -name FSM_3.rst_n -value 0</span><br><span class="line">#设置一些固定值，使用固定值来分析电路是否存在结构性问题（非必须）</span><br><span class="line">#set_case_analysis -name fsm.pi_money -value 0</span><br></pre></td></tr></table></figure><h3 id="（2）状态机分析"><a href="#（2）状态机分析" class="headerlink" title="（2）状态机分析"></a>（2）状态机分析</h3><p>读取设计文件FSM_3.v和上面写好的约束文件spyglass.sgdc，设置顶层模块为FSM_3，然后点击“Goal Setup”，勾选“adv_lint_verify”，然后点击“Run Goal”，等待报告结果。</p><p><img src="%E5%9B%BE9.png" alt="图9"></p><h3 id="（3）查看状态机"><a href="#（3）查看状态机" class="headerlink" title="（3）查看状态机"></a>（3）查看状态机</h3><p>如果设计没有问题，那么下方窗口显示如下，发现了存在状态机。</p><p><img src="%E5%9B%BE10.png" alt="图10"></p><p>双击该行后，弹出一个“Text Container”报告，点击OK关闭它，这时界面出现了一个新的图标，点击它。</p><p><img src="%E5%9B%BE11.png" alt="图11"></p><p>弹出了状态机图，可以放大和缩小，查看状态机跳转情况。</p><p><img src="%E5%9B%BE12.png" alt="图12"></p><ul><li>红色：无法到达的状态；</li><li>黑色：锁死状态，无法跳出；</li><li>红色线：带有箭头是已经分析的死跳转；</li><li>红色虚线：带有箭头是死跳转驱动；</li><li>蓝色：活锁状态，就是在几个状态中反复循环无法回到初始态；</li></ul><h1 id="3-Spyglass命令操作"><a href="#3-Spyglass命令操作" class="headerlink" title="3 Spyglass命令操作"></a>3 Spyglass命令操作</h1><p>上述操作完成后，退出Spyglass，提示是否保存工程，将其保存为FSM_3.prj，用文本编辑器打开，内容如下：</p><p><img src="%E5%9B%BE13.png" alt="图13"></p><p>这正是我们刚刚操作过的spyglass步骤，那么如何直接采用这些命令呢？</p><h2 id="3-1-读取和编译"><a href="#3-1-读取和编译" class="headerlink" title="3.1 读取和编译"></a>3.1 读取和编译</h2><p>在当前存在FSM_3.prj文件的目录下，使用-batch选项即可自动完成Spyglass的读取和编译，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spyglass -project FSM_3.prj -designread -batch |tee spyglass.log</span><br></pre></td></tr></table></figure><p>|tee spyglass.log是我另外加的，目的是为了让读取和编译的报告打印到当前目录下的spyglass.log文件中，其实不用加这句也行，因为Spyglass会自动将结果打印到当前目录下FSM_3&#x2F;FSM_3&#x2F;Design_Read&#x2F;spyglass.log中。</p><p><img src="%E5%9B%BE14.png" alt="图14"></p><h2 id="3-2-获取Goal列表"><a href="#3-2-获取Goal列表" class="headerlink" title="3.2 获取Goal列表"></a>3.2 获取Goal列表</h2><p>通过下面命令可以获取可用的Goal列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spyglass -project FSM_3.prj -showgoals</span><br></pre></td></tr></table></figure><p><img src="%E5%9B%BE15.png" alt="图15"></p><h2 id="3-3-运行Goal分析"><a href="#3-3-运行Goal分析" class="headerlink" title="3.3 运行Goal分析"></a>3.3 运行Goal分析</h2><p>我们试着跑“lint&#x2F;lint_rtl”分析，输入如下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spyglass -project FSM_3.prj -goals lint/lint_rtl -batch</span><br></pre></td></tr></table></figure><p>terminal在不断显示运行结果了，运行完毕后，打印信息提示我们可以到下列文件查看完整log文件：</p><p><img src="%E5%9B%BE17.png" alt="图17"></p><p>参考资料：</p><ol><li><p><a href="https://blog.csdn.net/qq_30843953/article/details/109629618">spyglass使用教程-CSDN博客</a></p></li><li><p>[Spyglass的CDC检查 - Galois_V - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/WenGalois123/p/17459291.html#:~:text=Spyglass%E7%9A%84CDC%E6%A3%80%E6%9F%A5">https://www.cnblogs.com/WenGalois123/p/17459291.html#:~:text=Spyglass的CDC检查</a> 接着前面Lint检查之后需要对RTL进行CDC检查，以下是简单的步骤。 1.在完成lint检查后，也就是确保没有语法错误之后，点击Goal Setup，然后勾选主窗口下cdc_setup_check，然后点击Run Goal,(s) ，当运行完成，会自动弹出Analyze Result窗口。 2.得到分析结果后， cdc%2Fcdc_setup_check文件夹消息。)</p></li><li><p><a href="https://www.cnblogs.com/xianyuIC/p/17488220.html">Spyglass学习笔记 - 咸鱼IC - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/116888880">芯片设计进阶之路——SpyGlass CDC流程深入理解(一) - 知乎 (zhihu.com)</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件工具学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spyglass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora使用教程</title>
      <link href="/2024/02/25/Typora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2024/02/25/Typora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>格式：*#+”空格”+标题（输入几个#就代表几级标题，最小六级标题）*</p><p>快捷键：Ctrl + 数字</p><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>语法：~~ + 文字 + ~~<br>快捷键：Alt + Shift + 5</p><p>可在文字上生成一道删除线</p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>语法：* + 文字 + *  或  _ + 文字 + _<br>快捷键：Ctrl + i</p><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p>语法：** + 文字 + ** 或者  __ + 文字 +__<br>快捷键：Ctrl + 文字</p><h3 id="斜体-加粗"><a href="#斜体-加粗" class="headerlink" title="斜体+加粗"></a>斜体+加粗</h3><p>语法：*** + 文字 + *** 或  ___ + 文字 + ___<br>快捷键：无</p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>语法：<u> + 文字 + </u><br>快捷键：Ctrl + u</p><h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><p>语法：&#x3D;&#x3D; + 文字 + &#x3D;&#x3D;<br>快捷键：无</p><h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><p>水:H ~ 2 ~ O<br>双氧水:H ~ 2 ~ O ~ 2</p><p>水:H<del>2</del>O</p><p>双氧水:H<del>2</del>O~2</p><h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><p>面积:m^2^<br>体积:m^3^</p><h3 id="常用表情"><a href="#常用表情" class="headerlink" title="常用表情"></a>常用表情</h3><p>😄😆😵😭😰😅😢😤 😍😎😩👍👎💯👏🔔🎁❓💣 ❤️☕️🌀 🙇💋🙏💦 💩 ❗️ 💢</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>可以在—分割线加入：设置表格对齐方式<br>“:——–“表示左对齐，”:———:“表示居中对齐，”———-:”表示右对齐</p><p>|Name | Age|<br>加入|:—:  | —:|<br>|Delta| 19|，变为</p><table><thead><tr><th align="center">Lisa</th><th align="right">21</th><th></th><th>Name</th><th>Age</th></tr></thead><tbody><tr><td align="center">Delta</td><td align="right">19</td><td></td><td></td><td></td></tr><tr><td align="center">Lisa</td><td align="right">21</td><td></td><td></td><td></td></tr></tbody></table><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>“&gt;” + 文字等</p><blockquote><p>这是一个引用</p></blockquote><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>”* “ + 有三种标记<br>“-”+ 三种标记功能一样<br>“+” + 都是无序列表</p><ul><li>有三种标记</li></ul><ul><li>三种标记功能一样</li></ul><ul><li>都是无序列表</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ol><li>数字加.是有序列表</li><li>数字的顺序不决定列表的顺序</li><li>推荐1 2 3 4 的顺序</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>语法: &#96;&#96;&#96;语法名称</p><p>import random<br>a &#x3D; random.random()</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>“******************************”<br>    ——————————      “<br>    ______________________________”</p><hr><hr><hr><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><ul><li><h4 id="外部跳转"><a href="#外部跳转" class="headerlink" title="外部跳转"></a>外部跳转</h4></li></ul><p>[文字]+（网址）</p><p><a href="https://www.baidu.com/">百度一下</a></p><ul><li><h4 id="内部跳转"><a href="#内部跳转" class="headerlink" title="内部跳转"></a>内部跳转</h4></li></ul><p> [对应文字] +（# 对应文字）</p><p>[二.Typora的语法](# 二.Typora的语法)</p><ul><li><h4 id="自动连接"><a href="#自动连接" class="headerlink" title="自动连接"></a>自动连接</h4></li></ul><p>&lt;网址&gt;</p><p><a href="https://www.baidu.com/">https://www.baidu.com</a></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>![自己起的图片名] + (图片地址或者图片本地存储的路径)</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>无序列表：- + 空格<br>有序列表：1. + 空格<br>引用：&gt; + 空格<br>标题：ctrl + 数字<br>表格：ctrl + t<br>生成目录：[TOC] + 回车<br>选中一整行：ctrl + l<br>选中单词：ctrl + d<br>选中相同格式的文字：ctrl + e<br>跳转到文章开头：ctrl + home<br>跳转到文章结尾：ctrl + end<br>搜索：ctrl + f<br>替换：ctrl + h<br>加粗：ctrl + b<br>倾斜：ctrl + i<br>下划线：ctrl + u<br>删除线：alt + shift + 5<br>插入图片：直接拖动到指定位置即可或者ctrl + shift + i<br>插入链接：ctrl + k</p>]]></content>
      
      
      <categories>
          
          <category> blog语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown基本操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片无法显示的问题</title>
      <link href="/2024/02/25/%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/02/25/%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h2><ul><li>进入你博客的根目录，右键单击, 然后选择 <code>git bash here</code> 打开 git bash.</li><li>键入命令 <code>npm install hexo-asset-image --save</code></li></ul><h2 id="修改插件"><a href="#修改插件" class="headerlink" title="修改插件"></a>修改插件</h2><ul><li>进入博客的根目录，然后下面顺序找到<code>index.js</code>:<br><code>node_modules</code> –&gt; <code>hexo-asset-image</code> –&gt; <code>index.js</code></li><li>用VS Code 或者 记事本打开 <code>index.js</code></li><li>在第 58 行，可以找到这么一行代码：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, config.<span class="property">root</span> + link + src);</span><br></pre></td></tr></table></figure><ul><li>把这一行代码改成下面这样</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, src);</span><br></pre></td></tr></table></figure><ul><li>保存文件</li></ul><p><img src="../%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/%E7%A5%9E%E5%A5%87%E5%AE%9D%E8%B4%9D.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> problem </category>
          
      </categories>
      
      
        <tags>
            
            <tag> problem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记</title>
      <link href="/2024/02/24/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/02/24/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="程序复杂度判断"><a href="#程序复杂度判断" class="headerlink" title="程序复杂度判断"></a>程序复杂度判断</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><h1 id="命名空间-namespace"><a href="#命名空间-namespace" class="headerlink" title="命名空间 namespace"></a>命名空间 namespace</h1><p>​在c++中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象等等。工程越大，名称互相冲突性的可能性越大。为了避免，在大规模程序的设计中，以及在程序员使用各种各样的C++库时，这些标识符的命名发生冲突，标准C++引入关键字namespace（命名空间&#x2F;名字空间&#x2F;名称空间）。</p><p>用法：<code>using namespace xxxx</code></p><h1 id="关键字-new"><a href="#关键字-new" class="headerlink" title="关键字 new"></a>关键字 new</h1><p>new创建类对象，使用完后需使用<strong>delete</strong>删除，跟申请内存类似。</p><p><strong>释放单个空间直接用delete，连续释放多个空间用delete[].</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CTest* pTest = <span class="keyword">new</span> <span class="built_in">CTest</span>();</span><br><span class="line"><span class="keyword">delete</span> pTest;</span><br><span class="line"><span class="number">1</span>）A  a；在栈(stack)上分配空间；</span><br><span class="line"><span class="number">2</span>）A  *a；只是声明，还没有分配空间；</span><br><span class="line"><span class="number">3</span>）A  *a= <span class="keyword">new</span> A；在堆(heap)上分配空间；</span><br></pre></td></tr></table></figure><p>C++有三种方法创建对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Test</span> &#123;   </span><br><span class="line">  <span class="keyword">private</span>:  </span><br><span class="line">  <span class="keyword">public</span>:  </span><br><span class="line">      <span class="built_in">add</span>()</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="type">int</span> x,y,sum;</span><br><span class="line">         x=<span class="number">5</span>;</span><br><span class="line">         y=<span class="number">5</span>;</span><br><span class="line">         sum=x+y;</span><br><span class="line">         cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;  </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">    Test test1;              <span class="comment">//栈中分配  ，由操作系统进行内存的分配和管理</span></span><br><span class="line">    Test test2 = <span class="built_in">Test</span>();       <span class="comment">//栈中分配  ，由操作系统进行内存的分配和管理</span></span><br><span class="line">    Test *test3=<span class="keyword">new</span> <span class="built_in">Test</span>();  <span class="comment">//堆中分配  ，由管理者进行内存的分配和管理，用完必须delete()，否则可能造成内存泄漏</span></span><br><span class="line">    test1.<span class="built_in">add</span>();</span><br><span class="line">    test2.<span class="built_in">add</span>();             <span class="comment">//&quot;.&quot; 是结构体成员引用</span></span><br><span class="line">    test3-&gt;<span class="built_in">add</span>();            <span class="comment">//&quot;-&gt;&quot;是指针引用</span></span><br><span class="line">    <span class="built_in">delete</span>(test3);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​第一种和第二种没什么区别，一个隐式调用，一个显式调用，两者都是在进程虚拟地址空间中的栈中分配内存。栈是系统数据结构，对于线程&#x2F;进程是唯一的，它的分配和释放由操作系统决定，不需要由开发者来管理。在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行完毕，系统会自动释放这些存储单元。</p><p>​第三种使用了new，在堆中分配了内存，堆上的内存分配，亦称动态内存分配。程序在运行的期间用malloc申请的内存，这部分内存由程序员自己负责管理，其生存期由开发者决定：在何时分配，分配多少，并在何时用free来释放该内存。这是唯一可以由开发者参与管理的内存。使用的好坏直接决定系统的性能和稳定。注意：栈中内存的分配和管理由操作系统决定，而堆中内存的分配和管理由管理者决定。</p><p>​我们需要的内存很少，你又能确定你到底需要多少内存时，用栈。当你需要在运行时才知道你到底需要多少内存时，请用堆。</p><p>下面是自己总结的一些关于new创建类对象特点：</p><ul><li>new创建类对象需要指针接收，一处初始化，多处使用</li><li>new创建类对象使用完需delete销毁</li><li>new创建对象直接使用堆空间，而局部不用new定义类对象则使用栈空间</li><li>new对象指针用途广泛，比如作为函数返回值、函数参数等</li><li>频繁调用场合并不适合new，就像new申请和释放内存一样</li></ul><p>参考：<a href="https://blog.csdn.net/weixin_40539125/article/details/83715393">【C++】创建对象之new关键字_c++ new一个对象-CSDN博客</a></p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="普通的结构体"><a href="#普通的结构体" class="headerlink" title="普通的结构体"></a>普通的结构体</h2><p>如下代码所示，引用的时候直接使用变量名+“.”+元素名称。例如<code>sqList.elem</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">elemtype* elem;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;sqList;</span><br></pre></td></tr></table></figure><h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p>创建方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    A* next;</span><br><span class="line">&#125;A;</span><br></pre></td></tr></table></figure><p>​引用该结构体时候，需要定义一个A类型的指针变量，该指针变量就是结构体指针。可以调用该结构体里的所有成员变量。例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A* test</span><br><span class="line">test -&gt; x;<span class="comment">//访问结构体中的x变量，也就是数据域</span></span><br><span class="line">text - &gt; next <span class="comment">// 访问结构体中的指针变量，也就是指针域。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​所谓容器，就是可以承载，包含元素的一个器件，它是<strong>STL</strong>六大组件之一，是容器、算法、迭代器中最重要也是最<strong>核心</strong>的一部分。</p><h2 id="结构与分类"><a href="#结构与分类" class="headerlink" title="结构与分类"></a>结构与分类</h2><h3 id="顺序性容器"><a href="#顺序性容器" class="headerlink" title="顺序性容器"></a>顺序性容器</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>顺序性容器就是将一组具有相同类型的元素以严格的线性形式组织起来。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><table><thead><tr><th>容器</th><th>简介说明</th></tr></thead><tbody><tr><td>vector</td><td>可变大小<strong>数组</strong>。相当于数组，可动态构建，支持随机访问，无头插和尾插，仅支持inset插入，除尾部外的元素删除比较麻烦。但使用最为广泛</td></tr><tr><td>deque</td><td><strong>双端队列</strong>。支持头插、删，尾插、删，随机访问较vector容器来说慢,但对于首尾的数据操作比较方便</td></tr><tr><td>list</td><td><strong>双向循环链表</strong>。使用起来很高效，对于任意位置的插入和删除都很快，在操作过后，以后指针、迭代器、引用都不会失效</td></tr><tr><td>forward_list</td><td><strong>单向链表</strong>。只支持单向访问，在链表的任何位置进行插入&#x2F;删除操作都非常快</td></tr><tr><td>array</td><td><strong>固定数组</strong>。vector的底层即为array数组，它保存了一个以严格顺序排列的特定数量的元素</td></tr></tbody></table><h4 id="vector使用"><a href="#vector使用" class="headerlink" title="vector使用"></a>vector使用</h4><table><thead><tr><th>头文件</th><th>#include <vector></vector></th></tr></thead><tbody><tr><td>push_back()&#x2F;insert()</td><td>存入数据，尾部插入</td></tr><tr><td>pop_back()</td><td>尾部删除</td></tr><tr><td>begin()</td><td>起始位置</td></tr><tr><td>end()</td><td>结束后+1</td></tr><tr><td>printvector()</td><td>打印容器元素</td></tr><tr><td>assign()</td><td>幅值操作</td></tr><tr><td>erase()</td><td>删除指定位置</td></tr><tr><td>clear（）</td><td>清空数组</td></tr><tr><td>capacity()</td><td>查询容量</td></tr><tr><td>size()</td><td>查询大小</td></tr><tr><td>empty()</td><td>查询容器是否为空</td></tr><tr><td>resize()</td><td>改变容器大小</td></tr></tbody></table><h4 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h4><p>​一般大多数的题目都可以使用vector容器，除非有特定需求使用其他容器更加合理方便；如果需要在一串数字的头尾进行操作，偏向deque，对于较中间的元素操作，不推荐 ；</p><p>对于中间的元素插入或删除，可采用forward_list（单向链表）或list（双向链表），不需要移动元素，只需改变相关结点的指针域即可；</p><h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>​关联式容器每一个元素都有一个键值（key），对于二元关联容器，还拥有实值（value）容器中的元素顺序不能由程序员来决定，有set（集合）和map（映射）这两大类，它们均是以RB-Tree（red-black tree，红黑树）为底层架构。</p><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><table><thead><tr><th>容器</th><th>简介说明</th></tr></thead><tbody><tr><td>set&#x2F;mutliset</td><td>集合&#x2F;多重集合。对于set，在使用insert插入元素时，已插入过的元素不可重复插入，这正好符合了集合的互异性，在插入完成显示后，会默认按照升序进行排序，对于multiset，可插入多个重复的元素</td></tr><tr><td>map&#x2F;mutlimap</td><td>映射&#x2F;多重映射。二者均为二元关联容器（在构造时需要写两个参数类型，前者对key值，后者对应value值），因为有两个参数，因此在插入元素的时候需要配合对组pair进行插入，具体见深入详解</td></tr></tbody></table><h3 id="使用场合-1"><a href="#使用场合-1" class="headerlink" title="使用场合"></a>使用场合</h3><p>​如果只负责查找内容，具体到某个单位，使用场景比如对手机游戏的个人的计分的存储，可以使用set或mutliset。</p><p>​如果需要同时放入容器的数据不止一个，并且是不同类型，比如一个为整型int,一个为string字符串型，就可以考虑使用map或mutlimap。</p><h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>​容器适配器是一个封装了序列容器的一个类模板&#x3D;，它在一般的序列容器的基础上提供了一些不同的功能。之所以称为容器适配器，是因为它是适配容器来提供其它不一样的功能。通过对应的容器和成员函数来实现我们需要的功能。</p><h3 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h3><table><thead><tr><th>容器</th><th>简介说明</th></tr></thead><tbody><tr><td>stack</td><td>堆栈。其原理是先进后出（FILO），其底层容器可以是任何标准的容器适配器，默认为deque双端队列</td></tr><tr><td>queue</td><td>队列。其原理是先进先出（FIFO），只有队头和队尾可以被访问，故不可有遍历行为，默认也为deque双端队列</td></tr><tr><td>pirority_queue</td><td>优先队列。它的第一个元素总是它所包含的元素中优先级最高的，就像数据结构里的堆，会默认形成大堆，还可以使用仿函数来控制生成大根堆还是生成小根堆，若没定义，默认使用vector容器</td></tr></tbody></table><h3 id="使用场合-2"><a href="#使用场合-2" class="headerlink" title="使用场合"></a>使用场合</h3><ul><li>对于 stack 堆栈，在我们日常生活中类似于坐地铁、电梯；</li><li>对于 deque 队列，在我们日常生活中类似于排队打饭；</li><li>对于 pirority_queue，因为其本质是堆，可以考虑解决一些贪心问题；</li></ul><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p>​泛化的指针。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><p><img src="11.png" alt="图片加载失败"></p><p>调用函数时，实参一般不会被改变,形参才会！</p><p>解读：实参相当于传入函数的是<strong>常数</strong>，函数对传入的参数进行一系列的运算后，传不出对应的结果。因为函数的结果保存在某个寄存器地址中，若要传出改结果，则需要传出该结果所在的地址。</p><p>以上内容参考自：</p><p><a href="https://zhuanlan.zhihu.com/p/564057584">知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/12/07/hello-world/"/>
      <url>/2023/12/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
